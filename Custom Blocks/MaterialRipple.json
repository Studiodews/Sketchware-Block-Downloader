[{"name":"MaterialRipple Lib","palette":"41","spec":"MaterialRipple Lib","type":" ","code":"\n}\npublic static class MaterialRippleLayout extends FrameLayout {\n    private static final int     DEFAULT_DURATION        \u003d 350;\n    private static final int     DEFAULT_FADE_DURATION   \u003d 75;\n    private static final float   DEFAULT_DIAMETER_DP     \u003d 35;\n    private static final float   DEFAULT_ALPHA           \u003d 0.2f;\n    private static final int     DEFAULT_COLOR           \u003d Color.BLACK;\n    private static final int     DEFAULT_BACKGROUND      \u003d Color.TRANSPARENT;\n    private static final boolean DEFAULT_HOVER           \u003d true;\n    private static final boolean DEFAULT_DELAY_CLICK     \u003d true;\n    private static final boolean DEFAULT_PERSISTENT      \u003d false;\n    private static final boolean DEFAULT_SEARCH_ADAPTER  \u003d false;\n    private static final boolean DEFAULT_RIPPLE_OVERLAY  \u003d false;\n    private static final int     DEFAULT_ROUNDED_CORNERS \u003d 0;\n    private static final int  FADE_EXTRA_DELAY \u003d 50;\n    private static final long HOVER_DURATION   \u003d 2500;\n    private final Paint paint  \u003d new Paint(Paint.ANTI_ALIAS_FLAG);\n    private final Rect  bounds \u003d new Rect();\n    private int      rippleColor;\n    private boolean  rippleOverlay;\n    private boolean  rippleHover;\n    private int      rippleDiameter;\n    private int      rippleDuration;\n    private int      rippleAlpha;\n    private boolean  rippleDelayClick;\n    private int      rippleFadeDuration;\n    private boolean  ripplePersistent;\n    private android.graphics.drawable.Drawable rippleBackground;\n    private boolean  rippleInAdapter;\n    private float    rippleRoundedCorners;\n    private float radius;\n    private AdapterView parentAdapter;\n    private View childView;\n    private AnimatorSet    rippleAnimator;\n    private ObjectAnimator hoverAnimator;\n    private Point currentCoords  \u003d new Point();\n    private Point previousCoords \u003d new Point();\n    private int layerType;\n    private boolean eventCancelled;\n    private boolean prepressed;\n    private int     positionInAdapter;\n    private GestureDetector   gestureDetector;\n    private PerformClickEvent pendingClickEvent;\n    private PressedEvent      pendingPressEvent;\n    public static RippleBuilder on(View view) {\n        return new RippleBuilder(view);\n    }\n    public MaterialRippleLayout(Context context) {\n        this(context, null, 0);\n    }\n    public MaterialRippleLayout(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n    public MaterialRippleLayout(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        setWillNotDraw(false);\n        gestureDetector \u003d new GestureDetector(context, longClickListener);\n        \n        rippleColor \u003d DEFAULT_COLOR;\n        rippleDiameter \u003d  (int) dpToPx(getResources(), DEFAULT_DIAMETER_DP);\n        rippleOverlay \u003d DEFAULT_RIPPLE_OVERLAY;\n        rippleHover \u003d DEFAULT_HOVER;\n        rippleDuration \u003d DEFAULT_DURATION;\n        rippleAlpha \u003d (int) (255 * DEFAULT_ALPHA);\n        rippleDelayClick \u003d DEFAULT_DELAY_CLICK;\n        rippleFadeDuration \u003d DEFAULT_FADE_DURATION;\n        rippleBackground \u003d new android.graphics.drawable.ColorDrawable(DEFAULT_BACKGROUND);\n        ripplePersistent \u003d DEFAULT_PERSISTENT;\n        rippleInAdapter \u003d DEFAULT_SEARCH_ADAPTER;\n        rippleRoundedCorners \u003d DEFAULT_ROUNDED_CORNERS;\n\n        paint.setColor(rippleColor);\n        paint.setAlpha(rippleAlpha);\n        enableClipPathSupportIfNecessary();\n    }\n    @SuppressWarnings(\"unchecked\")\n    public \u003cT extends View\u003e T getChildView() {\n        return (T) childView;\n    }\n    @Override\n    public final void addView(View child, int index, ViewGroup.LayoutParams params) {\n        if (getChildCount() \u003e 0) {\n            throw new IllegalStateException(\"MaterialRippleLayout can host only one child\");\n        }\n        childView \u003d child;\n        super.addView(child, index, params);\n    }\n    @Override\n    public void setOnClickListener(OnClickListener onClickListener) {\n        if (childView \u003d\u003d null) {\n            throw new IllegalStateException(\"MaterialRippleLayout must have a child view to handle clicks\");\n        }\n        childView.setOnClickListener(onClickListener);\n    }\n    @Override\n    public void setOnLongClickListener(OnLongClickListener onClickListener) {\n        if (childView \u003d\u003d null) {\n            throw new IllegalStateException(\"MaterialRippleLayout must have a child view to handle clicks\");\n        }\n        childView.setOnLongClickListener(onClickListener);\n    }\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent event) {\n        return !findClickableViewInChild(childView, (int) event.getX(), (int) event.getY());\n    }\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        boolean superOnTouchEvent \u003d super.onTouchEvent(event);\n        if (!isEnabled() || !childView.isEnabled()) return superOnTouchEvent;\n        boolean isEventInBounds \u003d bounds.contains((int) event.getX(), (int) event.getY());\n        if (isEventInBounds) {\n            previousCoords.set(currentCoords.x, currentCoords.y);\n            currentCoords.set((int) event.getX(), (int) event.getY());\n        }\n        boolean gestureResult \u003d gestureDetector.onTouchEvent(event);\n        if (gestureResult || hasPerformedLongPress) {\n            return true;\n        } else {\n            int action \u003d event.getActionMasked();\n            switch (action) {\n                case MotionEvent.ACTION_UP:\n                    pendingClickEvent \u003d new PerformClickEvent();\n                    if (prepressed) {\n                        childView.setPressed(true);\n                        postDelayed(\n                            new Runnable() {\n                                @Override public void run() {\n                                    childView.setPressed(false);\n                                }\n                            }, ViewConfiguration.getPressedStateDuration());\n                    }\n                    if (isEventInBounds) {\n                        startRipple(pendingClickEvent);\n                    } else if (!rippleHover) {\n                        setRadius(0);\n                    }\n                    if (!rippleDelayClick \u0026\u0026 isEventInBounds) {\n                        pendingClickEvent.run();\n                    }\n                    cancelPressedEvent();\n                    break;\n                case MotionEvent.ACTION_DOWN:\n                    setPositionInAdapter();\n                    eventCancelled \u003d false;\n                    pendingPressEvent \u003d new PressedEvent(event);\n                    if (isInScrollingContainer()) {\n                        cancelPressedEvent();\n                        prepressed \u003d true;\n                        postDelayed(pendingPressEvent, ViewConfiguration.getTapTimeout());\n                    } else {\n                        pendingPressEvent.run();\n                    }\n                    break;\n                case MotionEvent.ACTION_CANCEL:\n                    if (rippleInAdapter) {\n                        currentCoords.set(previousCoords.x, previousCoords.y);\n                        previousCoords \u003d new Point();\n                    }\n                    childView.onTouchEvent(event);\n                    if (rippleHover) {\n                        if (!prepressed) {\n                            startRipple(null);\n                        }\n                    } else {\n                        childView.setPressed(false);\n                    }\n                    cancelPressedEvent();\n                    break;\n                case MotionEvent.ACTION_MOVE:\n                    if (rippleHover) {\n                        if (isEventInBounds \u0026\u0026 !eventCancelled) {\n                            invalidate();\n                        } else if (!isEventInBounds) {\n                            startRipple(null);\n                        }\n                    }\n                    if (!isEventInBounds) {\n                        cancelPressedEvent();\n                        if (hoverAnimator !\u003d null) {\n                            hoverAnimator.cancel();\n                        }\n                        childView.onTouchEvent(event);\n                        eventCancelled \u003d true;\n                    }\n                    break;\n            }\n            return true;\n        }\n    }\n    private void cancelPressedEvent() {\n        if (pendingPressEvent !\u003d null) {\n            removeCallbacks(pendingPressEvent);\n            prepressed \u003d false;\n        }\n    }\n    private boolean hasPerformedLongPress;\n    private android.view.GestureDetector.SimpleOnGestureListener longClickListener \u003d new GestureDetector.SimpleOnGestureListener() {\n        public void onLongPress(MotionEvent e) {\n            hasPerformedLongPress \u003d childView.performLongClick();\n            if (hasPerformedLongPress) {\n                if (rippleHover) {\n                    startRipple(null);\n                }\n                cancelPressedEvent();\n            }\n        }\n        @Override\n        public boolean onDown(MotionEvent e) {\n            hasPerformedLongPress \u003d false;\n            return super.onDown(e);\n        }\n    };\n    private void startHover() {\n        if (eventCancelled) return;\n        if (hoverAnimator !\u003d null) {\n            hoverAnimator.cancel();\n        }\n        final float radius \u003d (float) (Math.sqrt(Math.pow(getWidth(), 2) + Math.pow(getHeight(), 2)) * 1.2f);\n        hoverAnimator \u003d ObjectAnimator.ofFloat(this, radiusProperty, rippleDiameter, radius)\n            .setDuration(HOVER_DURATION);\n        hoverAnimator.setInterpolator(new android.view.animation.LinearInterpolator());\n        hoverAnimator.start();\n    }\n    private void startRipple(final Runnable animationEndRunnable) {\n        if (eventCancelled) return;\n        float endRadius \u003d getEndRadius();\n        cancelAnimations();\n        rippleAnimator \u003d new AnimatorSet();\n        rippleAnimator.addListener(new AnimatorListenerAdapter() {\n            @Override public void onAnimationEnd(Animator animation) {\n                if (!ripplePersistent) {\n                    setRadius(0);\n                    setRippleAlpha(rippleAlpha);\n                }\n                if (animationEndRunnable !\u003d null \u0026\u0026 rippleDelayClick) {\n                    animationEndRunnable.run();\n                }\n                childView.setPressed(false);\n            }\n        });\n        ObjectAnimator ripple \u003d ObjectAnimator.ofFloat(this, radiusProperty, radius, endRadius);\n        ripple.setDuration(rippleDuration);\n        ripple.setInterpolator(new android.view.animation.DecelerateInterpolator());\n        ObjectAnimator fade \u003d ObjectAnimator.ofInt(this, circleAlphaProperty, rippleAlpha, 0);\n        fade.setDuration(rippleFadeDuration);\n        fade.setInterpolator(new android.view.animation.AccelerateInterpolator());\n        fade.setStartDelay(rippleDuration - rippleFadeDuration - FADE_EXTRA_DELAY);\n        if (ripplePersistent) {\n            rippleAnimator.play(ripple);\n        } else if (getRadius() \u003e endRadius) {\n            fade.setStartDelay(0);\n            rippleAnimator.play(fade);\n        } else {\n            rippleAnimator.playTogether(ripple, fade);\n        }\n        rippleAnimator.start();\n    }\n    private void cancelAnimations() {\n        if (rippleAnimator !\u003d null) {\n            rippleAnimator.cancel();\n            rippleAnimator.removeAllListeners();\n        }\n        if (hoverAnimator !\u003d null) {\n            hoverAnimator.cancel();\n        }\n    }\n    private float getEndRadius() {\n        final int width \u003d getWidth();\n        final int height \u003d getHeight();\n        final int halfWidth \u003d width / 2;\n        final int halfHeight \u003d height / 2;\n        final float radiusX \u003d halfWidth \u003e currentCoords.x ? width - currentCoords.x : currentCoords.x;\n        final float radiusY \u003d halfHeight \u003e currentCoords.y ? height - currentCoords.y : currentCoords.y;\n        return (float) Math.sqrt(Math.pow(radiusX, 2) + Math.pow(radiusY, 2)) * 1.2f;\n    }\n    private boolean isInScrollingContainer() {\n        ViewParent p \u003d getParent();\n        while (p !\u003d null \u0026\u0026 p instanceof ViewGroup) {\n            if (((ViewGroup) p).shouldDelayChildPressedState()) {\n                return true;\n            }\n            p \u003d p.getParent();\n        }\n        return false;\n    }\n    private AdapterView findParentAdapterView() {\n        if (parentAdapter !\u003d null) {\n            return parentAdapter;\n        }\n        ViewParent current \u003d getParent();\n        while (true) {\n            if (current instanceof AdapterView) {\n                parentAdapter \u003d (AdapterView) current;\n                return parentAdapter;\n            } else {\n                try {\n                    current \u003d current.getParent();\n                } catch (NullPointerException npe) {\n                    throw new RuntimeException(\"Could not find a parent AdapterView\");\n                }\n            }\n        }\n    }\n    private void setPositionInAdapter() {\n        if (rippleInAdapter) {\n            positionInAdapter \u003d findParentAdapterView().getPositionForView(MaterialRippleLayout.this);\n        }\n    }\n    private boolean adapterPositionChanged() {\n        if (rippleInAdapter) {\n            int newPosition \u003d findParentAdapterView().getPositionForView(MaterialRippleLayout.this);\n            final boolean changed \u003d newPosition !\u003d positionInAdapter;\n            positionInAdapter \u003d newPosition;\n            if (changed) {\n                cancelPressedEvent();\n                cancelAnimations();\n                childView.setPressed(false);\n                setRadius(0);\n            }\n            return changed;\n        }\n        return false;\n    }\n    private boolean findClickableViewInChild(View view, int x, int y) {\n        if (view instanceof ViewGroup) {\n            ViewGroup viewGroup \u003d (ViewGroup) view;\n            for (int i \u003d 0; i \u003c viewGroup.getChildCount(); i++) {\n                View child \u003d viewGroup.getChildAt(i);\n                final Rect rect \u003d new Rect();\n                child.getHitRect(rect);\n                final boolean contains \u003d rect.contains(x, y);\n                if (contains) {\n                    return findClickableViewInChild(child, x - rect.left, y - rect.top);\n                }\n            }\n        } else if (view !\u003d childView) {\n            return (view.isEnabled() \u0026\u0026 (view.isClickable() || view.isLongClickable() || view.isFocusableInTouchMode()));\n        }\n        return view.isFocusableInTouchMode();\n    }\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        bounds.set(0, 0, w, h);\n        rippleBackground.setBounds(bounds);\n    }\n    @Override\n    public boolean isInEditMode() {\n        return true;\n    }\n    @Override\n    public void draw(Canvas canvas) {\n        final boolean positionChanged \u003d adapterPositionChanged();\n        if (rippleOverlay) {\n            if (!positionChanged) {\n                rippleBackground.draw(canvas);\n            }\n            super.draw(canvas);\n            if (!positionChanged) {\n                if (rippleRoundedCorners !\u003d 0) {\n                    Path clipPath \u003d new Path();\n                    RectF rect \u003d new RectF(0, 0, canvas.getWidth(), canvas.getHeight());\n                    clipPath.addRoundRect(rect, rippleRoundedCorners, rippleRoundedCorners, Path.Direction.CW);\n                    canvas.clipPath(clipPath);\n                }\n                canvas.drawCircle(currentCoords.x, currentCoords.y, radius, paint);\n            }\n        } else {\n            if (!positionChanged) {\n                rippleBackground.draw(canvas);\n                canvas.drawCircle(currentCoords.x, currentCoords.y, radius, paint);\n            }\n            super.draw(canvas);\n        }\n    }\n    private Property\u003cMaterialRippleLayout, Float\u003e radiusProperty\n        \u003d new Property\u003cMaterialRippleLayout, Float\u003e(Float.class, \"radius\") {\n        @Override\n        public Float get(MaterialRippleLayout object) {\n            return object.getRadius();\n        }\n        @Override\n        public void set(MaterialRippleLayout object, Float value) {\n            object.setRadius(value);\n        }\n    };\n    private float getRadius() {\n        return radius;\n    }\n    public void setRadius(float radius) {\n        this.radius \u003d radius;\n        invalidate();\n    }\n    private Property\u003cMaterialRippleLayout, Integer\u003e circleAlphaProperty\n        \u003d new Property\u003cMaterialRippleLayout, Integer\u003e(Integer.class, \"rippleAlpha\") {\n        @Override\n        public Integer get(MaterialRippleLayout object) {\n            return object.getRippleAlpha();\n        }\n        @Override\n        public void set(MaterialRippleLayout object, Integer value) {\n            object.setRippleAlpha(value);\n        }\n    };\n    public int getRippleAlpha() {\n        return paint.getAlpha();\n    }\n    public void setRippleAlpha(Integer rippleAlpha) {\n        paint.setAlpha(rippleAlpha);\n        invalidate();\n    }\n    public void setRippleColor(int rippleColor) {\n        this.rippleColor \u003d rippleColor;\n        paint.setColor(rippleColor);\n        paint.setAlpha(rippleAlpha);\n        invalidate();\n    }\n    public void setRippleOverlay(boolean rippleOverlay) {\n        this.rippleOverlay \u003d rippleOverlay;\n    }\n    public void setRippleDiameter(int rippleDiameter) {\n        this.rippleDiameter \u003d rippleDiameter;\n    }\n    public void setRippleDuration(int rippleDuration) {\n        this.rippleDuration \u003d rippleDuration;\n    }\n    public void setRippleBackground(int color) {\n        rippleBackground \u003d new android.graphics.drawable.ColorDrawable(color);\n        rippleBackground.setBounds(bounds);\n        invalidate();\n    }\n    public void setRippleHover(boolean rippleHover) {\n        this.rippleHover \u003d rippleHover;\n    }\n    public void setRippleDelayClick(boolean rippleDelayClick) {\n        this.rippleDelayClick \u003d rippleDelayClick;\n    }\n    public void setRippleFadeDuration(int rippleFadeDuration) {\n        this.rippleFadeDuration \u003d rippleFadeDuration;\n    }\n    public void setRipplePersistent(boolean ripplePersistent) {\n        this.ripplePersistent \u003d ripplePersistent;\n    }\n    public void setRippleInAdapter(boolean rippleInAdapter) {\n        this.rippleInAdapter \u003d rippleInAdapter;\n    }\n    public void setRippleRoundedCorners(int rippleRoundedCorner) {\n        this.rippleRoundedCorners \u003d rippleRoundedCorner;\n        enableClipPathSupportIfNecessary();\n    }\n    public void setDefaultRippleAlpha(float alpha) {\n        this.rippleAlpha \u003d (int) (255 * alpha);\n        paint.setAlpha(rippleAlpha);\n        invalidate();\n    }\n    public void performRipple() {\n        currentCoords \u003d new Point(getWidth() / 2, getHeight() / 2);\n        startRipple(null);\n    }\n    public void performRipple(Point anchor) {\n        currentCoords \u003d new Point(anchor.x, anchor.y);\n        startRipple(null);\n    }\n    private void enableClipPathSupportIfNecessary() {\n        if (Build.VERSION.SDK_INT \u003c\u003d Build.VERSION_CODES.JELLY_BEAN_MR1) {\n            if (rippleRoundedCorners !\u003d 0) {\n                layerType \u003d getLayerType();\n                setLayerType(LAYER_TYPE_SOFTWARE, null);\n            } else {\n                setLayerType(layerType, null);\n            }\n        }\n    }\n    private class PerformClickEvent implements Runnable {\n        @Override public void run() {\n            if (hasPerformedLongPress) return;\n            if (getParent() instanceof AdapterView) {\n                if (!childView.performClick())\n                    clickAdapterView((AdapterView) getParent());\n            } else if (rippleInAdapter) {\n                clickAdapterView(findParentAdapterView());\n            } else {\n                childView.performClick();\n            }\n        }\n        private void clickAdapterView(AdapterView parent) {\n            final int position \u003d parent.getPositionForView(MaterialRippleLayout.this);\n            final long itemId \u003d parent.getAdapter() !\u003d null\n                ? parent.getAdapter().getItemId(position)\n                : 0;\n            if (position !\u003d AdapterView.INVALID_POSITION) {\n                parent.performItemClick(MaterialRippleLayout.this, position, itemId);\n            }\n        }\n    }\n    private final class PressedEvent implements Runnable {\n        private final MotionEvent event;\n        public PressedEvent(MotionEvent event) {\n            this.event \u003d event;\n        }\n        @Override\n        public void run() {\n            prepressed \u003d false;\n            childView.setLongClickable(false);\n            childView.onTouchEvent(event);\n            childView.setPressed(true);\n            if (rippleHover) {\n                startHover();\n            }\n        }\n    }\n    static float dpToPx(android.content.res.Resources resources, float dp) {\n        return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, resources.getDisplayMetrics());\n    }\n    public static class RippleBuilder {\n        private final Context context;\n        private final View    child;\n        private int     rippleColor         \u003d DEFAULT_COLOR;\n        private boolean rippleOverlay       \u003d DEFAULT_RIPPLE_OVERLAY;\n        private boolean rippleHover         \u003d DEFAULT_HOVER;\n        private float   rippleDiameter      \u003d DEFAULT_DIAMETER_DP;\n        private int     rippleDuration      \u003d DEFAULT_DURATION;\n        private float   rippleAlpha         \u003d DEFAULT_ALPHA;\n        private boolean rippleDelayClick    \u003d DEFAULT_DELAY_CLICK;\n        private int     rippleFadeDuration  \u003d DEFAULT_FADE_DURATION;\n        private boolean ripplePersistent    \u003d DEFAULT_PERSISTENT;\n        private int     rippleBackground    \u003d DEFAULT_BACKGROUND;\n        private boolean rippleSearchAdapter \u003d DEFAULT_SEARCH_ADAPTER;\n        private float   rippleRoundedCorner \u003d DEFAULT_ROUNDED_CORNERS;\n        public RippleBuilder(View child) {\n            this.child \u003d child;\n            this.context \u003d child.getContext();\n        }\n        public RippleBuilder rippleColor(int color) {\n            this.rippleColor \u003d color;\n            return this;\n        }\n        public RippleBuilder rippleOverlay(boolean overlay) {\n            this.rippleOverlay \u003d overlay;\n            return this;\n        }\n        public RippleBuilder rippleHover(boolean hover) {\n            this.rippleHover \u003d hover;\n            return this;\n        }\n        public RippleBuilder rippleDiameterDp(int diameterDp) {\n            this.rippleDiameter \u003d diameterDp;\n            return this;\n        }\n        public RippleBuilder rippleDuration(int duration) {\n            this.rippleDuration \u003d duration;\n            return this;\n        }\n        public RippleBuilder rippleAlpha(float alpha) {\n            this.rippleAlpha \u003d alpha;\n            return this;\n        }\n        public RippleBuilder rippleDelayClick(boolean delayClick) {\n            this.rippleDelayClick \u003d delayClick;\n            return this;\n        }\n        public RippleBuilder rippleFadeDuration(int fadeDuration) {\n            this.rippleFadeDuration \u003d fadeDuration;\n            return this;\n        }\n        public RippleBuilder ripplePersistent(boolean persistent) {\n            this.ripplePersistent \u003d persistent;\n            return this;\n        }\n        public RippleBuilder rippleBackground(int color) {\n            this.rippleBackground \u003d color;\n            return this;\n        }\n        public RippleBuilder rippleInAdapter(boolean inAdapter) {\n            this.rippleSearchAdapter \u003d inAdapter;\n            return this;\n        }\n        public RippleBuilder rippleRoundedCorners(int radiusDp) {\n            this.rippleRoundedCorner \u003d radiusDp;\n            return this;\n        }\n        public MaterialRippleLayout create() {\n            MaterialRippleLayout layout \u003d new MaterialRippleLayout(context);\n            layout.setRippleColor(rippleColor);\n            layout.setDefaultRippleAlpha(rippleAlpha);\n            layout.setRippleDelayClick(rippleDelayClick);\n            layout.setRippleDiameter((int) dpToPx(context.getResources(), rippleDiameter));\n            layout.setRippleDuration(rippleDuration);\n            layout.setRippleFadeDuration(rippleFadeDuration);\n            layout.setRippleHover(rippleHover);\n            layout.setRipplePersistent(ripplePersistent);\n            layout.setRippleOverlay(rippleOverlay);\n            layout.setRippleBackground(rippleBackground);\n            layout.setRippleInAdapter(rippleSearchAdapter);\n            layout.setRippleRoundedCorners((int) dpToPx(context.getResources(), rippleRoundedCorner));\n            ViewGroup.LayoutParams params \u003d child.getLayoutParams();\n            ViewGroup parent \u003d (ViewGroup) child.getParent();\n            int index \u003d 0;\n            if (parent !\u003d null \u0026\u0026 parent instanceof MaterialRippleLayout) {\n                throw new IllegalStateException(\"MaterialRippleLayout could not be created: parent of the view already is a MaterialRippleLayout\");\n            }\n            if (parent !\u003d null) {\n                index \u003d parent.indexOfChild(child);\n                parent.removeView(child);\n            }\n            layout.addView(child, new ViewGroup.LayoutParams(android.view.ViewGroup.LayoutParams.MATCH_PARENT, android.view.ViewGroup.LayoutParams.MATCH_PARENT));\n            if (parent !\u003d null) {\n                parent.addView(layout, index, params);\n            }\n            return layout;\n        }\n    }\n}\n{"},{"name":"MaterialRipple ","palette":"41","spec":"MaterialRipple%m.view colour%m.color","type":" ","code":"MaterialRippleLayout.on(%1$s)\n           .rippleColor(%2$s)\n           .create();"}]