[{"name":"TapTargetLibraryMoreblock","palette":"56","spec":"##TapTargetLibrary (add to Mblock)##","type":" ","code":"\n}static class UiUtil {\n    UiUtil() {\n    }\n    static int dp(Context context, int val) {\n        return (int) TypedValue.applyDimension(\n                TypedValue.COMPLEX_UNIT_DIP, val, context.getResources().getDisplayMetrics());\n    }\n    static int sp(Context context, int val) {\n        return (int) TypedValue.applyDimension(\n                TypedValue.COMPLEX_UNIT_SP, val, context.getResources().getDisplayMetrics());\n    }\n    static int themeIntAttr(Context context, String attr) {\n        final android.content.res.Resources.Theme theme \u003d context.getTheme();\n        if (theme \u003d\u003d null) {\n            return -1;\n        }\n        final TypedValue value \u003d new TypedValue();\n        final int id \u003d context.getResources().getIdentifier(attr, \"attr\", context.getPackageName());\n\n        if (id \u003d\u003d 0) {\n            // Not found\n            return -1;\n        }\n        theme.resolveAttribute(id, value, true);\n        return value.data;\n    }\n    static int setAlpha(int argb, float alpha) {\n        if (alpha \u003e 1.0f) {\n            alpha \u003d 1.0f;\n        } else if (alpha \u003c\u003d 0.0f) {\n            alpha \u003d 0.0f;\n        }\n        return ((int) ((argb \u003e\u003e\u003e 24) * alpha) \u003c\u003c 24) | (argb \u0026 0x00FFFFFF);\n    }\n}\n\t\tstatic class FloatValueAnimatorBuilder {\n\n    private final ValueAnimator animator;\n\n    private EndListener endListener;\n\n    interface UpdateListener {\n        void onUpdate(float lerpTime);\n    }\n    interface EndListener {\n        void onEnd();\n    }\n    protected FloatValueAnimatorBuilder() {\n        this(false);\n    }\n    FloatValueAnimatorBuilder(boolean reverse) {\n        if (reverse) {\n            this.animator \u003d ValueAnimator.ofFloat(1.0f, 0.0f);\n        } else {\n            this.animator \u003d ValueAnimator.ofFloat(0.0f, 1.0f);\n        }\n    }\n    public FloatValueAnimatorBuilder delayBy(long millis) {\n        animator.setStartDelay(millis);\n        return this;\n    }\n    public FloatValueAnimatorBuilder duration(long millis) {\n        animator.setDuration(millis);\n        return this;\n    }\n    public FloatValueAnimatorBuilder interpolator(TimeInterpolator lerper) {\n        animator.setInterpolator(lerper);\n        return this;\n    }\n    public FloatValueAnimatorBuilder repeat(int times) {\n        animator.setRepeatCount(times);\n        return this;\n    }\n    public FloatValueAnimatorBuilder onUpdate(final UpdateListener listener) {\n        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                listener.onUpdate((float) animation.getAnimatedValue());\n            }\n        });\n        return this;\n    }\n    public FloatValueAnimatorBuilder onEnd(final EndListener listener) {\n        this.endListener \u003d listener;\n        return this;\n    }\n    public ValueAnimator build() {\n        if (endListener !\u003d null) {\n            animator.addListener(new AnimatorListenerAdapter() {\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    endListener.onEnd();\n                }\n            });\n        }\n        return animator;\n    }\n}\n\t\tstatic class ReflectUtil {\n    ReflectUtil() {\n    }\n    static Object getPrivateField(Object source, String fieldName)\n            throws NoSuchFieldException, IllegalAccessException {\n        final java.lang.reflect.Field objectField \u003d source.getClass().getDeclaredField(fieldName);\n        objectField.setAccessible(true);\n        return objectField.get(source);\n    }\n}\n\t\tstatic class TapTarget extends Activity {\n    final CharSequence title;\n    final CharSequence description;\n    float outerCircleAlpha \u003d 0.96f;\n    int targetRadius \u003d 44;\n    Rect bounds;\n    android.graphics.drawable.Drawable icon;\n    Typeface titleTypeface;\n    Typeface descriptionTypeface;\n\n\n    private int outerCircleColorRes \u003d -1;\n    private int targetCircleColorRes \u003d -1;\n    private int dimColorRes \u003d -1;\n    private int titleTextColorRes \u003d -1;\n    private int descriptionTextColorRes \u003d -1;\n\n    private Integer outerCircleColor \u003d null;\n    private Integer targetCircleColor \u003d null;\n    private Integer dimColor \u003d null;\n    private Integer titleTextColor \u003d null;\n    private Integer descriptionTextColor \u003d null;\n\n    private int titleTextDimen \u003d -1;\n    private int descriptionTextDimen \u003d -1;\n    private int titleTextSize \u003d 20;\n    private int descriptionTextSize \u003d 18;\n    int id \u003d -1;\n    boolean drawShadow \u003d false;\n    boolean cancelable \u003d true;\n    boolean tintTarget \u003d true;\n    boolean transparentTarget \u003d false;\n    float descriptionTextAlpha \u003d 0.54f;\n\n    public static TapTarget forView(View view, CharSequence title) {\n        return forView(view, title, null);\n    }\n    public static TapTarget forView(View view, CharSequence title, CharSequence description) {\n        return new ViewTapTarget(view, title, description);\n    }\n    public static TapTarget forBounds(Rect bounds, CharSequence title) {\n        return forBounds(bounds, title, null);\n    }\n    public static TapTarget forBounds(Rect bounds, CharSequence title,  CharSequence description) {\n        return new TapTarget(bounds, title, description);\n    }\n    protected TapTarget(Rect bounds, CharSequence title,  CharSequence description) {\n        this(title, description);\n        if (bounds \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Cannot pass null bounds or title\");\n        }\n        this.bounds \u003d bounds;\n    }\n    protected TapTarget(CharSequence title,  CharSequence description) {\n        if (title \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Cannot pass null title\");\n        }\n        this.title \u003d title;\n        this.description \u003d description;\n    }\n    public TapTarget transparentTarget(boolean transparent) {\n        this.transparentTarget \u003d transparent;\n        return this;\n    }\n    public TapTarget outerCircleColor( int color) {\n        this.outerCircleColorRes \u003d color;\n        return this;\n    }\n    public TapTarget outerCircleColorInt( int color) {\n        this.outerCircleColor \u003d color;\n        return this;\n    }\n    public TapTarget outerCircleAlpha(float alpha) {\n        if (alpha \u003c 0.0f || alpha \u003e 1.0f) {\n            throw new IllegalArgumentException(\"Given an invalid alpha value: \" + alpha);\n        }\n        this.outerCircleAlpha \u003d alpha;\n        return this;\n    }\n    public TapTarget targetCircleColor( int color) {\n        this.targetCircleColorRes \u003d color;\n        return this;\n    }\n    public TapTarget targetCircleColorInt( int color) {\n        this.targetCircleColor \u003d color;\n        return this;\n    }\n    public TapTarget textColor( int color) {\n        this.titleTextColorRes \u003d color;\n        this.descriptionTextColorRes \u003d color;\n        return this;\n    }\n    public TapTarget textColorInt( int color) {\n        this.titleTextColor \u003d color;\n        this.descriptionTextColor \u003d color;\n        return this;\n    }\n    public TapTarget titleTextColor( int color) {\n        this.titleTextColorRes \u003d color;\n        return this;\n    }\n    public TapTarget titleTextColorInt( int color) {\n        this.titleTextColor \u003d color;\n        return this;\n    }\n    public TapTarget descriptionTextColor( int color) {\n        this.descriptionTextColorRes \u003d color;\n        return this;\n    }\n    public TapTarget descriptionTextColorInt( int color) {\n        this.descriptionTextColor \u003d color;\n        return this;\n    }\n    public TapTarget textTypeface(Typeface typeface) {\n        if (typeface \u003d\u003d null) throw new IllegalArgumentException(\"Cannot use a null typeface\");\n        titleTypeface \u003d typeface;\n        descriptionTypeface \u003d typeface;\n        return this;\n    }\n    public TapTarget titleTypeface(Typeface titleTypeface) {\n        if (titleTypeface \u003d\u003d null) throw new IllegalArgumentException(\"Cannot use a null typeface\");\n        this.titleTypeface \u003d titleTypeface;\n        return this;\n    }\n    public TapTarget descriptionTypeface(Typeface descriptionTypeface) {\n        if (descriptionTypeface \u003d\u003d null) throw new IllegalArgumentException(\"Cannot use a null typeface\");\n        this.descriptionTypeface \u003d descriptionTypeface;\n        return this;\n    }\n    public TapTarget titleTextSize(int sp) {\n        if (sp \u003c 0) throw new IllegalArgumentException(\"Given negative text size\");\n        this.titleTextSize \u003d sp;\n        return this;\n    }\n    public TapTarget descriptionTextSize(int sp) {\n        if (sp \u003c 0) throw new IllegalArgumentException(\"Given negative text size\");\n        this.descriptionTextSize \u003d sp;\n        return this;\n    }\n    public TapTarget titleTextDimen( int dimen) {\n        this.titleTextDimen \u003d dimen;\n        return this;\n    }\n    public TapTarget descriptionTextAlpha(float descriptionTextAlpha) {\n        if (descriptionTextAlpha \u003c 0 || descriptionTextAlpha \u003e 1f) {\n            throw new IllegalArgumentException(\"Given an invalid alpha value: \" + descriptionTextAlpha);\n        }\n        this.descriptionTextAlpha \u003d descriptionTextAlpha;\n        return this;\n    }\n    public TapTarget descriptionTextDimen( int dimen) {\n        this.descriptionTextDimen \u003d dimen;\n        return this;\n    }\n    public TapTarget dimColor( int color) {\n        this.dimColorRes \u003d color;\n        return this;\n    }\n    public TapTarget dimColorInt( int color) {\n        this.dimColor \u003d color;\n        return this;\n    }\n    public TapTarget drawShadow(boolean draw) {\n        this.drawShadow \u003d draw;\n        return this;\n    }\n    public TapTarget cancelable(boolean status) {\n        this.cancelable \u003d status;\n        return this;\n    }\n    public TapTarget tintTarget(boolean tint) {\n        this.tintTarget \u003d tint;\n        return this;\n    }\n    public TapTarget icon(android.graphics.drawable.Drawable icon) {\n        return icon(icon, false);\n    }\n    public TapTarget icon(android.graphics.drawable.Drawable icon, boolean hasSetBounds) {\n        if (icon \u003d\u003d null) throw new IllegalArgumentException(\"Cannot use null drawable\");\n        this.icon \u003d icon;\n        if (!hasSetBounds) {\n            this.icon.setBounds(new Rect(0, 0, this.icon.getIntrinsicWidth(), this.icon.getIntrinsicHeight()));\n        }\n        return this;\n    }\n    public TapTarget id(int id) {\n        this.id \u003d id;\n        return this;\n    }\n    public TapTarget targetRadius(int targetRadius) {\n        this.targetRadius \u003d targetRadius;\n        return this;\n    }\n    public int id() {\n        return id;\n    }\n    public void onReady(Runnable runnable) {\n        runnable.run();\n    }\n    public Rect bounds() {\n        if (bounds \u003d\u003d null) {\n            throw new IllegalStateException(\"Requesting bounds that are not set! Make sure your target is ready\");\n        }\n        return bounds;\n    }\n    Integer outerCircleColorInt(Context context) {\n        return colorResOrInt(context, outerCircleColor, outerCircleColorRes);\n    }\n    Integer targetCircleColorInt(Context context) {\n        return colorResOrInt(context, targetCircleColor, targetCircleColorRes);\n    }\n    Integer dimColorInt(Context context) {\n        return colorResOrInt(context, dimColor, dimColorRes);\n    }\n    Integer titleTextColorInt(Context context) {\n        return colorResOrInt(context, titleTextColor, titleTextColorRes);\n    }\n\n    Integer descriptionTextColorInt(Context context) {\n        return colorResOrInt(context, descriptionTextColor, descriptionTextColorRes);\n    }\n    int titleTextSizePx(Context context) {\n        return dimenOrSize(context, titleTextSize, titleTextDimen);\n    }\n    int descriptionTextSizePx(Context context) {\n        return dimenOrSize(context, descriptionTextSize, descriptionTextDimen);\n    }\n\n    private Integer colorResOrInt(Context context, Integer value,  int resource) {\n        if (resource !\u003d -1) {\n            if (Build.VERSION.SDK_INT \u003e\u003d Build.VERSION_CODES.M) {\n                return context.getColor(resource);\n            }\n        }\n        return value;\n    }\n    private int dimenOrSize(Context context, int size,  int dimen) {\n        if (dimen !\u003d -1) {\n            return context.getResources().getDimensionPixelSize(dimen);\n        }\n        return UiUtil.sp(context, size);\n    }\n}\n\t\tstatic class TapTargetView extends View {\n    private boolean isDismissed \u003d false;\n    private boolean isDismissing \u003d false;\n    private boolean isInteractable \u003d true;\n\n    final int TARGET_PADDING;\n    final int TARGET_RADIUS;\n    final int TARGET_PULSE_RADIUS;\n    final int TEXT_PADDING;\n    final int TEXT_SPACING;\n    final int TEXT_MAX_WIDTH;\n    final int TEXT_POSITIONING_BIAS;\n    final int CIRCLE_PADDING;\n    final int GUTTER_DIM;\n    final int SHADOW_DIM;\n    final int SHADOW_JITTER_DIM;\n\n\n    final ViewGroup boundingParent;\n    final ViewManager parent;\n    final TapTarget target;\n    final Rect targetBounds;\n\n    final TextPaint titlePaint;\n    final TextPaint descriptionPaint;\n    final Paint outerCirclePaint;\n    final Paint outerCircleShadowPaint;\n    final Paint targetCirclePaint;\n    final Paint targetCirclePulsePaint;\n\n    CharSequence title;\n\n    StaticLayout titleLayout;\n\n    CharSequence description;\n\n    StaticLayout descriptionLayout;\n    boolean isDark;\n    boolean debug;\n    boolean shouldTintTarget;\n    boolean shouldDrawShadow;\n    boolean cancelable;\n    boolean visible;\n\n    // Debug related variables\n\n    SpannableStringBuilder debugStringBuilder;\n\n    DynamicLayout debugLayout;\n\n    TextPaint debugTextPaint;\n\n    Paint debugPaint;\n\n    // Drawing properties\n    Rect drawingBounds;\n    Rect textBounds;\n\n    Path outerCirclePath;\n    float outerCircleRadius;\n    int calculatedOuterCircleRadius;\n    int[] outerCircleCenter;\n    int outerCircleAlpha;\n\n    float targetCirclePulseRadius;\n    int targetCirclePulseAlpha;\n\n    float targetCircleRadius;\n    int targetCircleAlpha;\n\n    int textAlpha;\n    int dimColor;\n\n    float lastTouchX;\n    float lastTouchY;\n\n    int topBoundary;\n    int bottomBoundary;\n\n    Bitmap tintedTarget;\n\n    Listener listener;\n\n\n    ViewOutlineProvider outlineProvider;\n\n    public static TapTargetView showFor(Activity activity, TapTarget target) {\n        return showFor(activity, target, null);\n    }\n\n    public static TapTargetView showFor(Activity activity, TapTarget target, Listener listener) {\n        if (activity \u003d\u003d null) throw new IllegalArgumentException(\"Activity is null\");\n\n        final ViewGroup decor \u003d (ViewGroup) activity.getWindow().getDecorView();\n        final ViewGroup.LayoutParams layoutParams \u003d new ViewGroup.LayoutParams(\n                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n        final ViewGroup content \u003d (ViewGroup) decor.findViewById(android.R.id.content);\n        final TapTargetView tapTargetView \u003d new TapTargetView(activity, decor, content, target, listener);\n        decor.addView(tapTargetView, layoutParams);\n\n        return tapTargetView;\n    }\n\n    public static TapTargetView showFor(Dialog dialog, TapTarget target) {\n        return showFor(dialog, target, null);\n    }\n\n    public static TapTargetView showFor(Dialog dialog, TapTarget target, Listener listener) {\n        if (dialog \u003d\u003d null) throw new IllegalArgumentException(\"Dialog is null\");\n\n        final Context context \u003d dialog.getContext();\n        final WindowManager windowManager \u003d (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n        final WindowManager.LayoutParams params \u003d new WindowManager.LayoutParams();\n        params.type \u003d WindowManager.LayoutParams.TYPE_APPLICATION;\n        params.format \u003d PixelFormat.RGBA_8888;\n        params.flags \u003d 0;\n        params.gravity \u003d Gravity.START | Gravity.TOP;\n        params.x \u003d 0;\n        params.y \u003d 0;\n        params.width \u003d WindowManager.LayoutParams.MATCH_PARENT;\n        params.height \u003d WindowManager.LayoutParams.MATCH_PARENT;\n\n        final TapTargetView tapTargetView \u003d new TapTargetView(context, windowManager, null, target, listener);\n        windowManager.addView(tapTargetView, params);\n\n        return tapTargetView;\n    }\n\n    public static class Listener {\n        /** Signals that the user has clicked inside of the target **/\n        public void onTargetClick(TapTargetView view) {\n            view.dismiss(true);\n        }\n\n        /** Signals that the user has long clicked inside of the target **/\n        public void onTargetLongClick(TapTargetView view) {\n            onTargetClick(view);\n        }\n\n        /** If cancelable, signals that the user has clicked outside of the outer circle **/\n        public void onTargetCancel(TapTargetView view) {\n            view.dismiss(false);\n        }\n\n        /** Signals that the user clicked on the outer circle portion of the tap target **/\n        public void onOuterCircleClick(TapTargetView view) {\n            // no-op as default\n        }\n\n        /**\n         * Signals that the tap target has been dismissed\n         * @param userInitiated Whether the user caused this action\n         *\n         *\n         */\n        public void onTargetDismissed(TapTargetView view, boolean userInitiated) {\n        }\n    }\n\n    final FloatValueAnimatorBuilder.UpdateListener expandContractUpdateListener \u003d new FloatValueAnimatorBuilder.UpdateListener() {\n        @Override\n        public void onUpdate(float lerpTime) {\n            final float newOuterCircleRadius \u003d calculatedOuterCircleRadius * lerpTime;\n            final boolean expanding \u003d newOuterCircleRadius \u003e outerCircleRadius;\n            if (!expanding) {\n                // When contracting we need to invalidate the old drawing bounds. Otherwise\n                // you will see artifacts as the circle gets smaller\n                calculateDrawingBounds();\n            }\n\n            final float targetAlpha \u003d target.outerCircleAlpha * 255;\n            outerCircleRadius \u003d newOuterCircleRadius;\n            outerCircleAlpha \u003d (int) Math.min(targetAlpha, (lerpTime * 1.5f * targetAlpha));\n            outerCirclePath.reset();\n            outerCirclePath.addCircle(outerCircleCenter[0], outerCircleCenter[1], outerCircleRadius, Path.Direction.CW);\n\n            targetCircleAlpha \u003d (int) Math.min(255.0f, (lerpTime * 1.5f * 255.0f));\n\n            if (expanding) {\n                targetCircleRadius \u003d TARGET_RADIUS * Math.min(1.0f, lerpTime * 1.5f);\n            } else {\n                targetCircleRadius \u003d TARGET_RADIUS * lerpTime;\n                targetCirclePulseRadius *\u003d lerpTime;\n            }\n\n            textAlpha \u003d (int) (delayedLerp(lerpTime, 0.7f) * 255);\n\n            if (expanding) {\n                calculateDrawingBounds();\n            }\n\n            invalidateViewAndOutline(drawingBounds);\n        }\n    };\n\n    final ValueAnimator expandAnimation \u003d new FloatValueAnimatorBuilder()\n            .duration(250)\n            .delayBy(250)\n            .interpolator(new AccelerateDecelerateInterpolator())\n            .onUpdate(new FloatValueAnimatorBuilder.UpdateListener() {\n                @Override\n                public void onUpdate(float lerpTime) {\n                    expandContractUpdateListener.onUpdate(lerpTime);\n                }\n            })\n            .onEnd(new FloatValueAnimatorBuilder.EndListener() {\n                @Override\n                public void onEnd() {\n                    pulseAnimation.start();\n                    isInteractable \u003d true;\n                }\n            })\n            .build();\n\n    final ValueAnimator pulseAnimation \u003d new FloatValueAnimatorBuilder()\n            .duration(1000)\n            .repeat(ValueAnimator.INFINITE)\n            .interpolator(new AccelerateDecelerateInterpolator())\n            .onUpdate(new FloatValueAnimatorBuilder.UpdateListener() {\n                @Override\n                public void onUpdate(float lerpTime) {\n                    final float pulseLerp \u003d delayedLerp(lerpTime, 0.5f);\n                    targetCirclePulseRadius \u003d (1.0f + pulseLerp) * TARGET_RADIUS;\n                    targetCirclePulseAlpha \u003d (int) ((1.0f - pulseLerp) * 255);\n                    targetCircleRadius \u003d TARGET_RADIUS + halfwayLerp(lerpTime) * TARGET_PULSE_RADIUS;\n\n                    if (outerCircleRadius !\u003d calculatedOuterCircleRadius) {\n                        outerCircleRadius \u003d calculatedOuterCircleRadius;\n                    }\n\n                    calculateDrawingBounds();\n                    invalidateViewAndOutline(drawingBounds);\n                }\n            })\n            .build();\n\n    final ValueAnimator dismissAnimation \u003d new FloatValueAnimatorBuilder(true)\n            .duration(250)\n            .interpolator(new AccelerateDecelerateInterpolator())\n            .onUpdate(new FloatValueAnimatorBuilder.UpdateListener() {\n                @Override\n                public void onUpdate(float lerpTime) {\n                    expandContractUpdateListener.onUpdate(lerpTime);\n                }\n            })\n            .onEnd(new FloatValueAnimatorBuilder.EndListener() {\n                @Override\n                public void onEnd() {\n                    onDismiss(true);\n                    ViewUtil.removeView(parent, TapTargetView.this);\n                }\n            })\n            .build();\n\n    private final ValueAnimator dismissConfirmAnimation \u003d new FloatValueAnimatorBuilder()\n            .duration(250)\n            .interpolator(new AccelerateDecelerateInterpolator())\n            .onUpdate(new FloatValueAnimatorBuilder.UpdateListener() {\n                @Override\n                public void onUpdate(float lerpTime) {\n                    final float spedUpLerp \u003d Math.min(1.0f, lerpTime * 2.0f);\n                    outerCircleRadius \u003d calculatedOuterCircleRadius * (1.0f + (spedUpLerp * 0.2f));\n                    outerCircleAlpha \u003d (int) ((1.0f - spedUpLerp) * target.outerCircleAlpha * 255.0f);\n                    outerCirclePath.reset();\n                    outerCirclePath.addCircle(outerCircleCenter[0], outerCircleCenter[1], outerCircleRadius, Path.Direction.CW);\n                    targetCircleRadius \u003d (1.0f - lerpTime) * TARGET_RADIUS;\n                    targetCircleAlpha \u003d (int) ((1.0f - lerpTime) * 255.0f);\n                    targetCirclePulseRadius \u003d (1.0f + lerpTime) * TARGET_RADIUS;\n                    targetCirclePulseAlpha \u003d (int) ((1.0f - lerpTime) * targetCirclePulseAlpha);\n                    textAlpha \u003d (int) ((1.0f - spedUpLerp) * 255.0f);\n                    calculateDrawingBounds();\n                    invalidateViewAndOutline(drawingBounds);\n                }\n            })\n            .onEnd(new FloatValueAnimatorBuilder.EndListener() {\n                @Override\n                public void onEnd() {\n                    onDismiss(true);\n                    ViewUtil.removeView(parent, TapTargetView.this);\n                }\n            })\n            .build();\n\n    private ValueAnimator[] animators \u003d new ValueAnimator[]\n            {expandAnimation, pulseAnimation, dismissConfirmAnimation, dismissAnimation};\n\n    private final ViewTreeObserver.OnGlobalLayoutListener globalLayoutListener;\n    public TapTargetView(final Context context,\n                         final ViewManager parent,\n                          final ViewGroup boundingParent,\n                         final TapTarget target,\n                          final Listener userListener) {\n        super(context);\n        if (target \u003d\u003d null) throw new IllegalArgumentException(\"Target cannot be null\");\n\n        this.target \u003d target;\n        this.parent \u003d parent;\n        this.boundingParent \u003d boundingParent;\n        this.listener \u003d userListener !\u003d null ? userListener : new Listener();\n        this.title \u003d target.title;\n        this.description \u003d target.description;\n\n        TARGET_PADDING \u003d UiUtil.dp(context, 20);\n        CIRCLE_PADDING \u003d UiUtil.dp(context, 40);\n        TARGET_RADIUS \u003d UiUtil.dp(context, target.targetRadius);\n        TEXT_PADDING \u003d UiUtil.dp(context, 40);\n        TEXT_SPACING \u003d UiUtil.dp(context, 8);\n        TEXT_MAX_WIDTH \u003d UiUtil.dp(context, 360);\n        TEXT_POSITIONING_BIAS \u003d UiUtil.dp(context, 20);\n        GUTTER_DIM \u003d UiUtil.dp(context, 88);\n        SHADOW_DIM \u003d UiUtil.dp(context, 8);\n        SHADOW_JITTER_DIM \u003d UiUtil.dp(context, 1);\n        TARGET_PULSE_RADIUS \u003d (int) (0.1f * TARGET_RADIUS);\n\n        outerCirclePath \u003d new Path();\n        targetBounds \u003d new Rect();\n        drawingBounds \u003d new Rect();\n\n        titlePaint \u003d new TextPaint();\n        titlePaint.setTextSize(target.titleTextSizePx(context));\n        titlePaint.setTypeface(Typeface.create(\"sans-serif-medium\", Typeface.NORMAL));\n        titlePaint.setAntiAlias(true);\n\n        descriptionPaint \u003d new TextPaint();\n        descriptionPaint.setTextSize(target.descriptionTextSizePx(context));\n        descriptionPaint.setTypeface(Typeface.create(Typeface.SANS_SERIF, Typeface.NORMAL));\n        descriptionPaint.setAntiAlias(true);\n        descriptionPaint.setAlpha((int) (0.54f * 255.0f));\n\n        outerCirclePaint \u003d new Paint();\n        outerCirclePaint.setAntiAlias(true);\n        outerCirclePaint.setAlpha((int) (target.outerCircleAlpha * 255.0f));\n\n        outerCircleShadowPaint \u003d new Paint();\n        outerCircleShadowPaint.setAntiAlias(true);\n        outerCircleShadowPaint.setAlpha(50);\n        outerCircleShadowPaint.setStyle(Paint.Style.STROKE);\n        outerCircleShadowPaint.setStrokeWidth(SHADOW_JITTER_DIM);\n        outerCircleShadowPaint.setColor(Color.BLACK);\n\n        targetCirclePaint \u003d new Paint();\n        targetCirclePaint.setAntiAlias(true);\n\n        targetCirclePulsePaint \u003d new Paint();\n        targetCirclePulsePaint.setAntiAlias(true);\n\n        applyTargetOptions(context);\n\n        globalLayoutListener \u003d new ViewTreeObserver.OnGlobalLayoutListener() {\n            @Override\n            public void onGlobalLayout() {\n                if (isDismissing) {\n                    return;\n                }\n                updateTextLayouts();\n                target.onReady(new Runnable() {\n                    @Override\n                    public void run() {\n                        final int[] offset \u003d new int[2];\n\n                        targetBounds.set(target.bounds());\n\n                        getLocationOnScreen(offset);\n                        targetBounds.offset(-offset[0], -offset[1]);\n\n                        if (boundingParent !\u003d null) {\n                            final WindowManager windowManager\n                                    \u003d (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n                            final DisplayMetrics displayMetrics \u003d new DisplayMetrics();\n                            windowManager.getDefaultDisplay().getMetrics(displayMetrics);\n\n                            final Rect rect \u003d new Rect();\n                            boundingParent.getWindowVisibleDisplayFrame(rect);\n\n                            // We bound the boundaries to be within the screen\u0027s coordinates to\n                            // handle the case where the layout bounds do not match\n                            // (like when FLAG_LAYOUT_NO_LIMITS is specified)\n                            topBoundary \u003d Math.max(0, rect.top);\n                            bottomBoundary \u003d Math.min(rect.bottom, displayMetrics.heightPixels);\n                        }\n\n                        drawTintedTarget();\n                        requestFocus();\n                        calculateDimensions();\n\n                        startExpandAnimation();\n                    }\n                });\n            }\n        };\n\n        getViewTreeObserver().addOnGlobalLayoutListener(globalLayoutListener);\n\n        setFocusableInTouchMode(true);\n        setClickable(true);\n        setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (listener \u003d\u003d null || outerCircleCenter \u003d\u003d null || !isInteractable) return;\n\n                final boolean clickedInTarget \u003d\n                        distance(targetBounds.centerX(), targetBounds.centerY(), (int) lastTouchX, (int) lastTouchY) \u003c\u003d targetCircleRadius;\n                final double distanceToOuterCircleCenter \u003d distance(outerCircleCenter[0], outerCircleCenter[1],\n                        (int) lastTouchX, (int) lastTouchY);\n                final boolean clickedInsideOfOuterCircle \u003d distanceToOuterCircleCenter \u003c\u003d outerCircleRadius;\n\n                if (clickedInTarget) {\n                    isInteractable \u003d false;\n                    listener.onTargetClick(TapTargetView.this);\n                } else if (clickedInsideOfOuterCircle) {\n                    listener.onOuterCircleClick(TapTargetView.this);\n                } else if (cancelable) {\n                    isInteractable \u003d false;\n                    listener.onTargetCancel(TapTargetView.this);\n                }\n            }\n        });\n\n        setOnLongClickListener(new OnLongClickListener() {\n            @Override\n            public boolean onLongClick(View v) {\n                if (listener \u003d\u003d null) return false;\n\n                if (targetBounds.contains((int) lastTouchX, (int) lastTouchY)) {\n                    listener.onTargetLongClick(TapTargetView.this);\n                    return true;\n                }\n\n                return false;\n            }\n        });\n    }\n\n    private void startExpandAnimation() {\n        if (!visible) {\n            isInteractable \u003d false;\n            expandAnimation.start();\n            visible \u003d true;\n        }\n    }\n\n    protected void applyTargetOptions(Context context) {\n        shouldTintTarget \u003d target.tintTarget;\n        shouldDrawShadow \u003d target.drawShadow;\n        cancelable \u003d target.cancelable;\n\n        // We can\u0027t clip out portions of a view outline, so if the user specified a transparent\n        // target, we need to fallback to drawing a jittered shadow approximation\n        if (shouldDrawShadow \u0026\u0026 Build.VERSION.SDK_INT \u003e\u003d 21 \u0026\u0026 !target.transparentTarget) {\n            outlineProvider \u003d new ViewOutlineProvider() {\n                @Override\n                public void getOutline(View view, Outline outline) {\n                    if (outerCircleCenter \u003d\u003d null) return;\n                    outline.setOval(\n                            (int) (outerCircleCenter[0] - outerCircleRadius), (int) (outerCircleCenter[1] - outerCircleRadius),\n                            (int) (outerCircleCenter[0] + outerCircleRadius), (int) (outerCircleCenter[1] + outerCircleRadius));\n                    outline.setAlpha(outerCircleAlpha / 255.0f);\n                    if (Build.VERSION.SDK_INT \u003e\u003d 22) {\n                        outline.offset(0, SHADOW_DIM);\n                    }\n                }\n            };\n\n            setOutlineProvider(outlineProvider);\n            setElevation(SHADOW_DIM);\n        }\n\n        if (shouldDrawShadow \u0026\u0026 outlineProvider \u003d\u003d null \u0026\u0026 Build.VERSION.SDK_INT \u003c 18) {\n            setLayerType(LAYER_TYPE_SOFTWARE, null);\n        } else {\n            setLayerType(LAYER_TYPE_HARDWARE, null);\n        }\n\n        final android.content.res.Resources.Theme theme \u003d context.getTheme();\n        isDark \u003d UiUtil.themeIntAttr(context, \"isLightTheme\") \u003d\u003d 0;\n\n        final Integer outerCircleColor \u003d target.outerCircleColorInt(context);\n        if (outerCircleColor !\u003d null) {\n            outerCirclePaint.setColor(outerCircleColor);\n        } else if (theme !\u003d null) {\n            outerCirclePaint.setColor(UiUtil.themeIntAttr(context, \"colorPrimary\"));\n        } else {\n            outerCirclePaint.setColor(Color.WHITE);\n        }\n\n        final Integer targetCircleColor \u003d target.targetCircleColorInt(context);\n        if (targetCircleColor !\u003d null) {\n            targetCirclePaint.setColor(targetCircleColor);\n        } else {\n            targetCirclePaint.setColor(isDark ? Color.BLACK : Color.WHITE);\n        }\n\n        if (target.transparentTarget) {\n            targetCirclePaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));\n        }\n\n        targetCirclePulsePaint.setColor(targetCirclePaint.getColor());\n\n        final Integer targetDimColor \u003d target.dimColorInt(context);\n        if (targetDimColor !\u003d null) {\n            dimColor \u003d UiUtil.setAlpha(targetDimColor, 0.3f);\n        } else {\n            dimColor \u003d -1;\n        }\n\n        final Integer titleTextColor \u003d target.titleTextColorInt(context);\n        if (titleTextColor !\u003d null) {\n            titlePaint.setColor(titleTextColor);\n        } else {\n            titlePaint.setColor(isDark ? Color.BLACK : Color.WHITE);\n        }\n\n        final Integer descriptionTextColor \u003d target.descriptionTextColorInt(context);\n        if (descriptionTextColor !\u003d null) {\n            descriptionPaint.setColor(descriptionTextColor);\n        } else {\n            descriptionPaint.setColor(titlePaint.getColor());\n        }\n\n        if (target.titleTypeface !\u003d null) {\n            titlePaint.setTypeface(target.titleTypeface);\n        }\n\n        if (target.descriptionTypeface !\u003d null) {\n            descriptionPaint.setTypeface(target.descriptionTypeface);\n        }\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        onDismiss(false);\n    }\n\n    void onDismiss(boolean userInitiated) {\n        if (isDismissed) return;\n\n        isDismissing \u003d false;\n        isDismissed \u003d true;\n\n        for (final ValueAnimator animator : animators) {\n            animator.cancel();\n            animator.removeAllUpdateListeners();\n        }\n        ViewUtil.removeOnGlobalLayoutListener(getViewTreeObserver(), globalLayoutListener);\n        visible \u003d false;\n\n        if (listener !\u003d null) {\n            listener.onTargetDismissed(this, userInitiated);\n        }\n    }\n\n    @Override\n    protected void onDraw(Canvas c) {\n        if (isDismissed || outerCircleCenter \u003d\u003d null) return;\n\n        if (topBoundary \u003e 0 \u0026\u0026 bottomBoundary \u003e 0) {\n            c.clipRect(0, topBoundary, getWidth(), bottomBoundary);\n        }\n\n        if (dimColor !\u003d -1) {\n            c.drawColor(dimColor);\n        }\n\n        int saveCount;\n        outerCirclePaint.setAlpha(outerCircleAlpha);\n        if (shouldDrawShadow \u0026\u0026 outlineProvider \u003d\u003d null) {\n            saveCount \u003d c.save();\n            {\n                c.clipPath(outerCirclePath, Region.Op.DIFFERENCE);\n                drawJitteredShadow(c);\n            }\n            c.restoreToCount(saveCount);\n        }\n        c.drawCircle(outerCircleCenter[0], outerCircleCenter[1], outerCircleRadius, outerCirclePaint);\n\n        targetCirclePaint.setAlpha(targetCircleAlpha);\n        if (targetCirclePulseAlpha \u003e 0) {\n            targetCirclePulsePaint.setAlpha(targetCirclePulseAlpha);\n            c.drawCircle(targetBounds.centerX(), targetBounds.centerY(),\n                    targetCirclePulseRadius, targetCirclePulsePaint);\n        }\n        c.drawCircle(targetBounds.centerX(), targetBounds.centerY(),\n                targetCircleRadius, targetCirclePaint);\n\n        saveCount \u003d c.save();\n        {\n            c.translate(textBounds.left, textBounds.top);\n            titlePaint.setAlpha(textAlpha);\n            if (titleLayout !\u003d null) {\n                titleLayout.draw(c);\n            }\n\n            if (descriptionLayout !\u003d null \u0026\u0026 titleLayout !\u003d null) {\n                c.translate(0, titleLayout.getHeight() + TEXT_SPACING);\n                descriptionPaint.setAlpha((int) (target.descriptionTextAlpha * textAlpha));\n                descriptionLayout.draw(c);\n            }\n        }\n        c.restoreToCount(saveCount);\n\n        saveCount \u003d c.save();\n        {\n            if (tintedTarget !\u003d null) {\n                c.translate(targetBounds.centerX() - tintedTarget.getWidth() / 2,\n                        targetBounds.centerY() - tintedTarget.getHeight() / 2);\n                c.drawBitmap(tintedTarget, 0, 0, targetCirclePaint);\n            } else if (target.icon !\u003d null) {\n                c.translate(targetBounds.centerX() - target.icon.getBounds().width() / 2,\n                        targetBounds.centerY() - target.icon.getBounds().height() / 2);\n                target.icon.setAlpha(targetCirclePaint.getAlpha());\n                target.icon.draw(c);\n            }\n        }\n        c.restoreToCount(saveCount);\n\n        if (debug) {\n            drawDebugInformation(c);\n        }\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent e) {\n        lastTouchX \u003d e.getX();\n        lastTouchY \u003d e.getY();\n        return super.onTouchEvent(e);\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if (isVisible() \u0026\u0026 cancelable \u0026\u0026 keyCode \u003d\u003d KeyEvent.KEYCODE_BACK) {\n            event.startTracking();\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        if (isVisible() \u0026\u0026 isInteractable \u0026\u0026 cancelable\n                \u0026\u0026 keyCode \u003d\u003d KeyEvent.KEYCODE_BACK \u0026\u0026 event.isTracking() \u0026\u0026 !event.isCanceled()) {\n            isInteractable \u003d false;\n\n            if (listener !\u003d null) {\n                listener.onTargetCancel(this);\n            } else {\n                new Listener().onTargetCancel(this);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Dismiss this view\n     * @param tappedTarget If the user tapped the target or not\n     *                     (results in different dismiss animations)\n     */\n    public void dismiss(boolean tappedTarget) {\n        isDismissing \u003d true;\n        pulseAnimation.cancel();\n        expandAnimation.cancel();\n        if (tappedTarget) {\n            dismissConfirmAnimation.start();\n        } else {\n            dismissAnimation.start();\n        }\n    }\n\n    /** Specify whether to draw a wireframe around the view, useful for debugging **/\n    public void setDrawDebug(boolean status) {\n        if (debug !\u003d status) {\n            debug \u003d status;\n            postInvalidate();\n        }\n    }\n\n    /** Returns whether this view is visible or not **/\n    public boolean isVisible() {\n        return !isDismissed \u0026\u0026 visible;\n    }\n\n    void drawJitteredShadow(Canvas c) {\n        final float baseAlpha \u003d 0.20f * outerCircleAlpha;\n        outerCircleShadowPaint.setStyle(Paint.Style.FILL_AND_STROKE);\n        outerCircleShadowPaint.setAlpha((int) baseAlpha);\n        c.drawCircle(outerCircleCenter[0], outerCircleCenter[1] + SHADOW_DIM, outerCircleRadius, outerCircleShadowPaint);\n        outerCircleShadowPaint.setStyle(Paint.Style.STROKE);\n        final int numJitters \u003d 7;\n        for (int i \u003d numJitters - 1; i \u003e 0; --i) {\n            outerCircleShadowPaint.setAlpha((int) ((i / (float) numJitters) * baseAlpha));\n            c.drawCircle(outerCircleCenter[0], outerCircleCenter[1] + SHADOW_DIM ,\n                    outerCircleRadius + (numJitters - i) * SHADOW_JITTER_DIM , outerCircleShadowPaint);\n        }\n    }\n\n    void drawDebugInformation(Canvas c) {\n        if (debugPaint \u003d\u003d null) {\n            debugPaint \u003d new Paint();\n            debugPaint.setARGB(255, 255, 0, 0);\n            debugPaint.setStyle(Paint.Style.STROKE);\n            debugPaint.setStrokeWidth(UiUtil.dp(getContext(), 1));\n        }\n\n        if (debugTextPaint \u003d\u003d null) {\n            debugTextPaint \u003d new TextPaint();\n            debugTextPaint.setColor(0xFFFF0000);\n            debugTextPaint.setTextSize(UiUtil.sp(getContext(), 16));\n        }\n\n        // Draw wireframe\n        debugPaint.setStyle(Paint.Style.STROKE);\n        c.drawRect(textBounds, debugPaint);\n        c.drawRect(targetBounds, debugPaint);\n        c.drawCircle(outerCircleCenter[0], outerCircleCenter[1], 10, debugPaint);\n        c.drawCircle(outerCircleCenter[0], outerCircleCenter[1], calculatedOuterCircleRadius - CIRCLE_PADDING, debugPaint);\n        c.drawCircle(targetBounds.centerX(), targetBounds.centerY(), TARGET_RADIUS + TARGET_PADDING, debugPaint);\n\n        // Draw positions and dimensions\n        debugPaint.setStyle(Paint.Style.FILL);\n        final String debugText \u003d\n                \"Text bounds: \" + textBounds.toShortString() + \"n\" +\n                        \"Target bounds: \" + targetBounds.toShortString() + \"n\" +\n                        \"Center: \" + outerCircleCenter[0] + \" \" + outerCircleCenter[1] + \"n\" +\n                        \"View size: \" + getWidth() + \" \" + getHeight() + \"n\" +\n                        \"Target bounds: \" + targetBounds.toShortString();\n\n        if (debugStringBuilder \u003d\u003d null) {\n            debugStringBuilder \u003d new SpannableStringBuilder(debugText);\n        } else {\n            debugStringBuilder.clear();\n            debugStringBuilder.append(debugText);\n        }\n\n        if (debugLayout \u003d\u003d null) {\n            debugLayout \u003d new DynamicLayout(debugText, debugTextPaint, getWidth(), Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);\n        }\n\n        final int saveCount \u003d c.save();\n        {\n            debugPaint.setARGB(220, 0, 0, 0);\n            c.translate(0.0f, topBoundary);\n            c.drawRect(0.0f, 0.0f, debugLayout.getWidth(), debugLayout.getHeight(), debugPaint);\n            debugPaint.setARGB(255, 255, 0, 0);\n            debugLayout.draw(c);\n        }\n        c.restoreToCount(saveCount);\n    }\n\n    void drawTintedTarget() {\n        final android.graphics.drawable.Drawable icon \u003d target.icon;\n        if (!shouldTintTarget || icon \u003d\u003d null) {\n            tintedTarget \u003d null;\n            return;\n        }\n\n        if (tintedTarget !\u003d null) return;\n\n        tintedTarget \u003d Bitmap.createBitmap(icon.getIntrinsicWidth(), icon.getIntrinsicHeight(),\n                Bitmap.Config.ARGB_8888);\n        final Canvas canvas \u003d new Canvas(tintedTarget);\n        icon.setColorFilter(new PorterDuffColorFilter(\n                outerCirclePaint.getColor(), PorterDuff.Mode.SRC_ATOP));\n        icon.draw(canvas);\n        icon.setColorFilter(null);\n    }\n\n    void updateTextLayouts() {\n        final int textWidth \u003d Math.min(getWidth(), TEXT_MAX_WIDTH) - TEXT_PADDING * 2;\n        if (textWidth \u003c\u003d 0) {\n            return;\n        }\n\n        titleLayout \u003d new StaticLayout(title, titlePaint, textWidth,\n                Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);\n\n        if (description !\u003d null) {\n            descriptionLayout \u003d new StaticLayout(description, descriptionPaint, textWidth,\n                    Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);\n        } else {\n            descriptionLayout \u003d null;\n        }\n    }\n\n    float halfwayLerp(float lerp) {\n        if (lerp \u003c 0.5f) {\n            return lerp / 0.5f;\n        }\n\n        return (1.0f - lerp) / 0.5f;\n    }\n\n    float delayedLerp(float lerp, float threshold) {\n        if (lerp \u003c threshold) {\n            return 0.0f;\n        }\n\n        return (lerp - threshold) / (1.0f - threshold);\n    }\n\n    void calculateDimensions() {\n        textBounds \u003d getTextBounds();\n        outerCircleCenter \u003d getOuterCircleCenterPoint();\n        calculatedOuterCircleRadius \u003d getOuterCircleRadius(outerCircleCenter[0], outerCircleCenter[1], textBounds, targetBounds);\n    }\n\n    void calculateDrawingBounds() {\n        if (outerCircleCenter \u003d\u003d null) {\n            // Called dismiss before we got a chance to display the tap target\n            // So we have no center -\u003e cant determine the drawing bounds\n            return;\n        }\n        drawingBounds.left \u003d (int) Math.max(0, outerCircleCenter[0] - outerCircleRadius);\n        drawingBounds.top \u003d (int) Math.min(0, outerCircleCenter[1] - outerCircleRadius);\n        drawingBounds.right \u003d (int) Math.min(getWidth(),\n                outerCircleCenter[0] + outerCircleRadius + CIRCLE_PADDING);\n        drawingBounds.bottom \u003d (int) Math.min(getHeight(),\n                outerCircleCenter[1] + outerCircleRadius + CIRCLE_PADDING);\n    }\n\n    int getOuterCircleRadius(int centerX, int centerY, Rect textBounds, Rect targetBounds) {\n        final int targetCenterX \u003d targetBounds.centerX();\n        final int targetCenterY \u003d targetBounds.centerY();\n        final int expandedRadius \u003d (int) (1.1f * TARGET_RADIUS);\n        final Rect expandedBounds \u003d new Rect(targetCenterX, targetCenterY, targetCenterX, targetCenterY);\n        expandedBounds.inset(-expandedRadius, -expandedRadius);\n\n        final int textRadius \u003d maxDistanceToPoints(centerX, centerY, textBounds);\n        final int targetRadius \u003d maxDistanceToPoints(centerX, centerY, expandedBounds);\n        return Math.max(textRadius, targetRadius) + CIRCLE_PADDING;\n    }\n\n    Rect getTextBounds() {\n        final int totalTextHeight \u003d getTotalTextHeight();\n        final int totalTextWidth \u003d getTotalTextWidth();\n\n        final int possibleTop \u003d targetBounds.centerY() - TARGET_RADIUS - TARGET_PADDING - totalTextHeight;\n        final int top;\n        if (possibleTop \u003e topBoundary) {\n            top \u003d possibleTop;\n        } else {\n            top \u003d targetBounds.centerY() + TARGET_RADIUS + TARGET_PADDING;\n        }\n\n        final int relativeCenterDistance \u003d (getWidth() / 2) - targetBounds.centerX();\n        final int bias \u003d relativeCenterDistance \u003c 0 ? -TEXT_POSITIONING_BIAS : TEXT_POSITIONING_BIAS;\n        final int left \u003d Math.max(TEXT_PADDING, targetBounds.centerX() - bias - totalTextWidth);\n        final int right \u003d Math.min(getWidth() - TEXT_PADDING, left + totalTextWidth);\n        return new Rect(left, top, right, top + totalTextHeight);\n    }\n\n    int[] getOuterCircleCenterPoint() {\n        if (inGutter(targetBounds.centerY())) {\n            return new int[]{targetBounds.centerX(), targetBounds.centerY()};\n        }\n\n        final int targetRadius \u003d Math.max(targetBounds.width(), targetBounds.height()) / 2 + TARGET_PADDING;\n        final int totalTextHeight \u003d getTotalTextHeight();\n\n        final boolean onTop \u003d targetBounds.centerY() - TARGET_RADIUS - TARGET_PADDING - totalTextHeight \u003e 0;\n\n        final int left \u003d Math.min(textBounds.left, targetBounds.left - targetRadius);\n        final int right \u003d Math.max(textBounds.right, targetBounds.right + targetRadius);\n        final int titleHeight \u003d titleLayout \u003d\u003d null ? 0 : titleLayout.getHeight();\n        final int centerY \u003d onTop ?\n                targetBounds.centerY() - TARGET_RADIUS - TARGET_PADDING - totalTextHeight + titleHeight\n                :\n                targetBounds.centerY() + TARGET_RADIUS + TARGET_PADDING + titleHeight;\n\n        return new int[] { (left + right) / 2, centerY };\n    }\n\n    int getTotalTextHeight() {\n        if (titleLayout \u003d\u003d null) {\n            return 0;\n        }\n\n        if (descriptionLayout \u003d\u003d null) {\n            return titleLayout.getHeight() + TEXT_SPACING;\n        }\n\n        return titleLayout.getHeight() + descriptionLayout.getHeight() + TEXT_SPACING;\n    }\n\n    int getTotalTextWidth() {\n        if (titleLayout \u003d\u003d null) {\n            return 0;\n        }\n\n        if (descriptionLayout \u003d\u003d null) {\n            return titleLayout.getWidth();\n        }\n\n        return Math.max(titleLayout.getWidth(), descriptionLayout.getWidth());\n    }\n    boolean inGutter(int y) {\n        if (bottomBoundary \u003e 0) {\n            return y \u003c GUTTER_DIM || y \u003e bottomBoundary - GUTTER_DIM;\n        } else {\n            return y \u003c GUTTER_DIM || y \u003e getHeight() - GUTTER_DIM;\n        }\n    }\n    int maxDistanceToPoints(int x1, int y1, Rect bounds) {\n        final double tl \u003d distance(x1, y1, bounds.left, bounds.top);\n        final double tr \u003d distance(x1, y1, bounds.right, bounds.top);\n        final double bl \u003d distance(x1, y1, bounds.left, bounds.bottom);\n        final double br \u003d distance(x1, y1, bounds.right, bounds.bottom);\n        return (int) Math.max(tl, Math.max(tr, Math.max(bl, br)));\n    }\n    double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n    void invalidateViewAndOutline(Rect bounds) {\n        invalidate(bounds);\n        if (outlineProvider !\u003d null \u0026\u0026 Build.VERSION.SDK_INT \u003e\u003d 21) {\n            invalidateOutline();\n        }\n    }\n}\n\t\tstatic class ViewUtil {\n\n    ViewUtil() {}\n\n    private static boolean isLaidOut(View view) {\n        return true;\n    }\n    static void onLaidOut(final View view, final Runnable runnable) {\n        if (isLaidOut(view)) {\n            runnable.run();\n            return;\n        }\n        final ViewTreeObserver observer \u003d view.getViewTreeObserver();\n        observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n            @Override\n            public void onGlobalLayout() {\n                final ViewTreeObserver trueObserver;\n                if (observer.isAlive()) {\n                    trueObserver \u003d observer;\n                } else {\n                    trueObserver \u003d view.getViewTreeObserver();\n                }\n                removeOnGlobalLayoutListener(trueObserver, this);\n                runnable.run();\n            }\n        });\n    }\n    @SuppressWarnings(\"deprecation\")\n    static void removeOnGlobalLayoutListener(ViewTreeObserver observer,\n                                             ViewTreeObserver.OnGlobalLayoutListener listener) {\n        if (Build.VERSION.SDK_INT \u003e\u003d 16) {\n            observer.removeOnGlobalLayoutListener(listener);\n        } else {\n            observer.removeGlobalOnLayoutListener(listener);\n        }\n    }\n    static void removeView(ViewManager parent, View child) {\n        if (parent \u003d\u003d null || child \u003d\u003d null) {\n            return;\n        }\n        try {\n            parent.removeView(child);\n        } catch (Exception ignored) {\n        }\n    }\n}\n\t\tstatic class ViewTapTarget extends TapTarget {\n    final View view;\n\n    ViewTapTarget(View view, CharSequence title,  CharSequence description) {\n        super(title, description);\n        if (view \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Given null view to target\");\n        }\n        this.view \u003d view;\n    }\n\n    @Override\n    public void onReady(final Runnable runnable) {\n        ViewUtil.onLaidOut(view, new Runnable() {\n            @Override\n            public void run() {\n                // Cache bounds\n                final int[] location \u003d new int[2];\n                view.getLocationOnScreen(location);\n                bounds \u003d new Rect(location[0], location[1],\n                        location[0] + view.getWidth(), location[1] + view.getHeight());\n\n                if (icon \u003d\u003d null \u0026\u0026 view.getWidth() \u003e 0 \u0026\u0026 view.getHeight() \u003e 0) {\n                    final Bitmap viewBitmap \u003d Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);\n                    final Canvas canvas \u003d new Canvas(viewBitmap);\n                    view.draw(canvas);\n                    icon \u003d new android.graphics.drawable.BitmapDrawable(view.getContext().getResources(), viewBitmap);\n                    icon.setBounds(0, 0, icon.getIntrinsicWidth(), icon.getIntrinsicHeight());\n                }\n\n                runnable.run();\n            }\n        });\n    }\n}\n\t\tstatic class TapTargetSequence {\n    private final Activity activity;\n    private final Dialog dialog;\n    private final Queue\u003cTapTarget\u003e targets;\n    private boolean active;\n    private TapTargetView currentView;\n    Listener listener;\n    boolean considerOuterCircleCanceled;\n    boolean continueOnCancel;\n    public interface Listener {\n        void onSequenceFinish();\n        void onSequenceStep(TapTarget lastTarget, boolean targetClicked);\n        void onSequenceCanceled(TapTarget lastTarget);\n    }\n    public TapTargetSequence(Activity activity) {\n        if (activity \u003d\u003d null) throw new IllegalArgumentException(\"Activity is null\");\n        this.activity \u003d activity;\n        this.dialog \u003d null;\n        this.targets \u003d new LinkedList\u003c\u003e();\n    }\n    public TapTargetSequence(Dialog dialog) {\n        if (dialog \u003d\u003d null) throw new IllegalArgumentException(\"Given null Dialog\");\n        this.dialog \u003d dialog;\n        this.activity \u003d null;\n        this.targets \u003d new LinkedList\u003c\u003e();\n    }\n    public TapTargetSequence targets(List\u003cTapTarget\u003e targets) {\n        this.targets.addAll(targets);\n        return this;\n    }\n    public TapTargetSequence targets(TapTarget... targets) {\n        Collections.addAll(this.targets, targets);\n        return this;\n    }\n    public TapTargetSequence target(TapTarget target) {\n        this.targets.add(target);\n        return this;\n    }\n    public TapTargetSequence continueOnCancel(boolean status) {\n        this.continueOnCancel \u003d status;\n        return this;\n    }\n    public TapTargetSequence considerOuterCircleCanceled(boolean status) {\n        this.considerOuterCircleCanceled \u003d status;\n        return this;\n    }\n    public TapTargetSequence listener(Listener listener) {\n        this.listener \u003d listener;\n        return this;\n    }\n    public void start() {\n        if (targets.isEmpty() || active) {\n            return;\n        }\n        active \u003d true;\n        showNext();\n    }\n    public void startWith(int targetId) {\n        if (active) {\n            return;\n        }\n        while (targets.peek() !\u003d null \u0026\u0026 targets.peek().id() !\u003d targetId) {\n            targets.poll();\n        }\n        TapTarget peekedTarget \u003d targets.peek();\n        if (peekedTarget \u003d\u003d null || peekedTarget.id() !\u003d targetId) {\n            throw new IllegalStateException(\"Given target \" + targetId + \" not in sequence\");\n        }\n        start();\n    }\n    public void startAt(int index) {\n        if (active) {\n            return;\n        }\n        if (index \u003c 0 || index \u003e\u003d targets.size()) {\n            throw new IllegalArgumentException(\"Given invalid index \" + index);\n        }\n        final int expectedSize \u003d targets.size() - index;\n        while (targets.peek() !\u003d null \u0026\u0026 targets.size() !\u003d expectedSize) {\n            targets.poll();\n        }\n        if (targets.size() !\u003d expectedSize) {\n            throw new IllegalStateException(\"Given index \" + index + \" not in sequence\");\n        }\n        start();\n    }\n    public boolean cancel() {\n        if (targets.isEmpty() || !active) {\n            return false;\n        }\n        if (currentView \u003d\u003d null || !currentView.cancelable) {\n            return false;\n        }\n        currentView.dismiss(false);\n        active \u003d false;\n        targets.clear();\n        if (listener !\u003d null) {\n            listener.onSequenceCanceled(currentView.target);\n        }\n        return true;\n    }\n    void showNext() {\n        try {\n            TapTarget tapTarget \u003d targets.remove();\n            if (activity !\u003d null) {\n                currentView \u003d TapTargetView.showFor(activity, tapTarget, tapTargetListener);\n            } else {\n                currentView \u003d TapTargetView.showFor(dialog, tapTarget, tapTargetListener);\n            }\n        } catch (NoSuchElementException e) {\n            // No more targets\n            if (listener !\u003d null) {\n                listener.onSequenceFinish();\n            }\n        }\n    }\n    private final TapTargetView.Listener tapTargetListener \u003d new TapTargetView.Listener() {\n        @Override\n        public void onTargetClick(TapTargetView view) {\n            super.onTargetClick(view);\n            if (listener !\u003d null) {\n                listener.onSequenceStep(view.target, true);\n            }\n            showNext();\n        }\n        @Override\n        public void onOuterCircleClick(TapTargetView view) {\n            if (considerOuterCircleCanceled) {\n                onTargetCancel(view);\n            }\n        }\n        @Override\n        public void onTargetCancel(TapTargetView view) {\n            super.onTargetCancel(view);\n            if (continueOnCancel) {\n                if (listener !\u003d null) {\n                    listener.onSequenceStep(view.target, false);\n                }\n                showNext();\n            } else {\n                if (listener !\u003d null) {\n                    listener.onSequenceCanceled(view.target);\n                }\n            }\n        }\n    };"},{"name":"TapTarget","palette":"56","spec":"TapTarget on %m.activity view %m.view title %s content %s color %s","type":" ","code":"TapTargetView.showFor(%1$s.this,\n\n\n\nTapTarget.forView(%2$s, %3$s, %4$s)\n\n                            .outerCircleColorInt(Color.parseColor(%5$s))\n\n                            .outerCircleAlpha(0.99f)\n\n                            .targetCircleColor(android.R.color.white)\n\n                            .titleTextSize(24)\n\n                            .titleTextColor(android.R.color.white)\n\n                            .descriptionTextSize(18)\n\n                            .descriptionTextColor(android.R.color.white)\n\n                            .textColor(android.R.color.white)\n\n                            .textTypeface(Typeface.SANS_SERIF)\n\n                            .dimColor(android.R.color.black)\n\n                            .drawShadow(true)\n\n                            .cancelable(false)\n\n                            .tintTarget(true)\n\n                            .transparentTarget(true)\n\n                            .targetRadius(60),\n\n                new TapTargetView.Listener() {\n\n                    @Override\n\n                    public void onTargetClick(TapTargetView view) {\n\n                        super.onTargetClick(view);\n\n               \n\n  \n\n  }\n\n                });"},{"name":"ShareApkLibOnCreate","palette":"56","spec":"##StrictModeVmPolicy##","type":" ","typeName":"","color":"#FF1DE9B6","code":"\t\t\tStrictMode.VmPolicy.Builder builder \u003d \n\t\t\t\tnew StrictMode.VmPolicy.Builder(); \n\t\t\t\tStrictMode.setVmPolicy(builder.build());\n\t\t\t\tif(Build.VERSION.SDK_INT\u003e\u003d24){ \n\t\t\t\t\t    try{\n\t\t\t\t\t\t\t\tjava.lang.reflect.Method m \u003d \n\t\t\t\t\t\t        StrictMode.class.getMethod(\n\t\t\t\t\t\t\t\t\"disableDeathOnFileUriExposure\"); \n\t\t\t\t\t\t        m.invoke(null); \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(Exception e){ \n\t\t\t\t\t\t\t\tshowMessage(e.toString()); \n\t\t\t\t\t\t\t} \n\t\t\t\t}"},{"name":"ShareApplicationOnViewClick","palette":"56","spec":"Share application on %m.view clicked","type":" ","code":"\t\t%1$s.setOnClickListener(new View.OnClickListener(){\n\t\t\t@Override\n\t\t\tpublic void onClick(View _view){\n\t\t\t\tshareApplication();\n\t\t\t}\n\t\t});"},{"name":"Share Apk","palette":"56","spec":"Share Application","type":" ","typeName":"","color":"#FF1DE9B6","code":"shareApplication();"},{"name":"ShareApkLibMoreblock","palette":"56","spec":"##Share apk with name (example : myApp.apk) %s and shareInfo %s (add to Mblock)##","type":" ","code":"}\nprivate void shareApplication() { \n\t\t\t\t\t\tandroid.content.pm.ApplicationInfo app \u003d \n\t\t\t\t\t\tgetApplicationContext().getApplicationInfo(); \n\t\t\t\t\t\tString filePath \u003d app.sourceDir;\n\t\t\t\t\t\tIntent intent \u003d new Intent(Intent.ACTION_SEND); \n\t\t\t\t\t\tintent.setType(\"*/*\"); \n\t\t\t\t\t\tjava.io.File originalApk \u003d new java.io.File(filePath); \n\t\t\t\t\t\ttry {  \n\t\t\t\t\t\t\t\tjava.io.File tempFile \u003d new java.io.File(getExternalCacheDir() + \"/ExtractedApk\"); \n\t\t\t\t\t\t \t\tif (!tempFile.isDirectory()) \n\t\t\t\t\t\t\t\t\tif (!tempFile.mkdirs()) \n\t\t\t\t\t\t\t\t\treturn; \n\t\t\t\t\t\t\t\t\ttempFile \u003d new java.io.File(tempFile.getPath() + \"/\" + \n\t\t\t\t\t\t\t\t\t%1$s);\n\t\t\t\t\t\t\t\t\tif (!tempFile.exists()) \n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (!tempFile.createNewFile()) { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn; }\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcatch (java.io.IOException e){} \n\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\tjava.io.InputStream in \u003d new java.io.FileInputStream (originalApk);\n\t\t\t\t\t\t\t\t\tjava.io.OutputStream out \u003d new java.io.FileOutputStream(tempFile);\n\t\t\t\t\t\t\t\t\tbyte[] buf \u003d new byte[1024];\n\t\t\t\t\t\t\t\t\tint len; \n\t\t\t\t\t\t\t\t\twhile ((len \u003d in.read(buf)) \u003e 0) { \n\t\t\t\t\t\t\t\t\t\t\t\tout.write(buf, 0, len); \n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\tin.close(); \n\t\t\t\t\t\t\t\t\tout.close(); \n\t\t\t\t\t\t\t\t\tintent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(tempFile));\n\t\t\t\t\t\t\t\t\tstartActivity(Intent.createChooser(intent, %2$s));\n\t\t\t\t\t\t} \n\t\t\t\t\t\tcatch (java.io.IOException e) \n\t\t\t\t\t\t{ showMessage(e.toString()); \n\t\t\t\t\t\t} \n\t\t\t}\n{"},{"name":"GoogleProgressLibMoreblock","palette":"56","spec":"##GoogleProgressLibMoreblock##","type":" ","code":"}\npublic static class GoogleProgressBar extends ProgressBar {\n\tpublic static int _type \u003d 0;\n\tpublic static int[] _color \u003d new int[]{0xFFC93437, 0xFF375BF1, 0xFFF7D23E, 0xFF34A350}; //Red, blue, yellow, green\n    private enum ProgressType {\n        FOLDING_CIRCLES,\n        GOOGLE_MUSIC_DICES,\n        NEXUS_ROTATION_CROSS,\n        CHROME_FLOATING_CIRCLES\n    }\n    public GoogleProgressBar(Context context) {\n        this(context, null);\n    }\n    public GoogleProgressBar(Context context, AttributeSet attrs) {\n        this(context, attrs,android.R.attr.progressBarStyle);\n    }\n    public GoogleProgressBar(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        if (isInEditMode())\n            return;\n        final int typeIndex \u003d _type;\n\t\tfinal int[] colorsId \u003d _color;\n        android.graphics.drawable.Drawable drawable \u003d buildDrawable(context,typeIndex,colorsId);\n        if(drawable!\u003dnull)\n        setIndeterminateDrawable(drawable);\n    }\n    private android.graphics.drawable.Drawable buildDrawable(Context context, int typeIndex,int[] colorsId) {\n        android.graphics.drawable.Drawable drawable \u003d null;\n        ProgressType type \u003d ProgressType.values()[typeIndex];\n        switch (type){\n            case FOLDING_CIRCLES:\n                drawable \u003d new FoldingCirclesDrawable.Builder(context).colors(colorsId).build();\n                break;\n            case GOOGLE_MUSIC_DICES:\n                drawable \u003d new GoogleMusicDicesDrawable.Builder().build();\n                break;\n            case NEXUS_ROTATION_CROSS:\n                drawable \u003d new NexusRotationCrossDrawable.Builder(context).colors(colorsId).build();\n                break;\n            case CHROME_FLOATING_CIRCLES:\n                drawable \u003d new ChromeFloatingCirclesDrawable.Builder(context).colors(colorsId).build();\n                break;\n        }\n        return drawable;\n    }\n    public static void setType(int types) {\n    \t_type \u003d types;\n    }\n    public static void setColor(int[] colors) {\n    \t_color \u003d colors;\n    }\n}\n\n\npublic static class NexusRotationCrossDrawable extends android.graphics.drawable.Drawable implements android.graphics.drawable.Drawable.Callback {\n    private static int ANIMATION_DURATION \u003d 150;\n    private static int ANIMATION_START_DELAY \u003d 300;\n    private static final android.view.animation.Interpolator LINEAR_INTERPOLATOR \u003d new LinearInterpolator();\n    private int mCenter;\n    private Point[] mArrowPoints;\n    private Path mPath;\n    private Paint mPaint1;\n    private Paint mPaint2;\n    private Paint mPaint3;\n    private Paint mPaint4;\n    private int mRotationAngle;\n    public NexusRotationCrossDrawable(int[] colors) {\n        mArrowPoints \u003d new Point[5];\n        mPath \u003d new Path();\n        mPaint1 \u003d new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint1.setColor(colors[0]);\n        mPaint2 \u003d new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint2.setColor(colors[1]);\n        mPaint3 \u003d new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint3.setColor(colors[2]);\n        mPaint4 \u003d new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint4.setColor(colors[3]);\n        initObjectAnimator();\n    }\n    private void initObjectAnimator() {\n        final ObjectAnimator objectAnimator \u003d ObjectAnimator.ofInt(this, \"rotationAngle\", 0, 180);\n        objectAnimator.setInterpolator(LINEAR_INTERPOLATOR);\n        objectAnimator.setDuration(ANIMATION_DURATION);\n        objectAnimator.addListener(new AnimatorListenerAdapter() {\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                if (mRotationAngle \u003d\u003d 180) {\n                    objectAnimator.setIntValues(180, 360);\n                    objectAnimator.setStartDelay(ANIMATION_START_DELAY * 2);\n                } else {\n                    objectAnimator.setIntValues(0, 180);\n                    objectAnimator.setStartDelay(ANIMATION_START_DELAY);\n                    mRotationAngle \u003d 0;\n                }\n                objectAnimator.start();\n            }\n        });\n        objectAnimator.start();\n    }\n    @Override\n    public void draw(Canvas canvas) {\n        drawArrows(canvas);\n    }\n    private void drawArrows(Canvas canvas) {\n        canvas.rotate(mRotationAngle, mCenter, mCenter);\n        mPath.reset();\n        mPath.moveTo(mArrowPoints[0].x, mArrowPoints[0].y);\n        for (int i \u003d 1; i \u003c mArrowPoints.length; i++) {\n            mPath.lineTo(mArrowPoints[i].x, mArrowPoints[i].y);\n        }\n        mPath.lineTo(mArrowPoints[0].x, mArrowPoints[0].y);\n        canvas.save();\n        canvas.drawPath(mPath, mPaint1);\n        canvas.restore();\n        canvas.save();\n        canvas.rotate(90, mCenter, mCenter);\n        canvas.drawPath(mPath, mPaint2);\n        canvas.restore();\n        canvas.save();\n        canvas.rotate(180, mCenter, mCenter);\n        canvas.drawPath(mPath, mPaint3);\n        canvas.restore();\n        canvas.save();\n        canvas.rotate(270, mCenter, mCenter);\n        canvas.drawPath(mPath, mPaint4);\n        canvas.restore();\n    }\n    @Override\n    public void invalidateDrawable(android.graphics.drawable.Drawable who) {\n        final Callback callback \u003d getCallback();\n        if (callback !\u003d null) {\n            callback.invalidateDrawable(this);\n        }\n    }\n    @Override\n    public void scheduleDrawable(android.graphics.drawable.Drawable who, Runnable what, long when) {\n        final Callback callback \u003d getCallback();\n        if (callback !\u003d null) {\n            callback.scheduleDrawable(this, what, when);\n        }\n    }\n    @Override\n    public void unscheduleDrawable(android.graphics.drawable.Drawable who, Runnable what) {\n        final Callback callback \u003d getCallback();\n        if (callback !\u003d null) {\n            callback.unscheduleDrawable(this, what);\n        }\n    }\n    @Override\n    public void setAlpha(int alpha) {\n        mPaint1.setAlpha(alpha);\n        mPaint2.setAlpha(alpha);\n        mPaint3.setAlpha(alpha);\n        mPaint4.setAlpha(alpha);\n    }\n    @Override\n    public void setColorFilter(ColorFilter cf) {\n        mPaint1.setColorFilter(cf);\n        mPaint2.setColorFilter(cf);\n        mPaint3.setColorFilter(cf);\n        mPaint4.setColorFilter(cf);\n    }\n    @Override\n    protected void onBoundsChange(Rect bounds) {\n        super.onBoundsChange(bounds);\n        measureDrawable(bounds);\n    }\n    private void measureDrawable(Rect bounds) {\n        mCenter \u003d bounds.centerX();\n        int arrowMargin \u003d bounds.width() / 50;\n        int arrowWidth \u003d bounds.width() / 15;\n        int padding \u003d mCenter - (int) (mCenter /  Math.sqrt(2));\n        mArrowPoints[0] \u003d new Point(mCenter - arrowMargin, mCenter - arrowMargin);\n        mArrowPoints[1] \u003d new Point(mArrowPoints[0].x, mArrowPoints[0].y - arrowWidth);\n        mArrowPoints[2] \u003d new Point(padding + arrowWidth, padding);\n        mArrowPoints[3] \u003d new Point(padding, padding + arrowWidth);\n        mArrowPoints[4] \u003d new Point(mArrowPoints[0].x - arrowWidth, mArrowPoints[0].y);\n    }\n    @Override\n    public int getOpacity() {\n        return PixelFormat.TRANSLUCENT;\n    }\n    void setRotationAngle(int angle) {\n        mRotationAngle \u003d angle;\n    }\n    int getRotationAngle() {\n        return mRotationAngle;\n    }\n    public static class Builder {\n        private int[] mColors;\n        public Builder(Context context) {\n            initDefaults(context);\n        }\n        \n        private void initDefaults(Context context) {\n            mColors \u003d new int[]{0xFFC93437, 0xFF375BF1, 0xFFF7D23E, 0xFF34A350}; //Red, blue, yellow, green\n        }\n        \n        public Builder colors(int[] colors) {\n            if (colors \u003d\u003d null || colors.length !\u003d 4) {\n                throw new IllegalArgumentException(\"Your color array must contains 4 values\");\n            }\n            mColors \u003d colors;\n            return this;\n        }\n        public android.graphics.drawable.Drawable build() {\n            return new NexusRotationCrossDrawable(mColors);\n        }\n    }\n}\n\n\npublic static class GoogleMusicDicesDrawable extends android.graphics.drawable.Drawable implements android.graphics.drawable.Drawable.Callback {\n    private static final int DICE_SIDE_COLOR \u003d Color.parseColor(\"#FFDBDBDB\");\n    private static final int DICE_SIDE_SHADOW_COLOR \u003d Color.parseColor(\"#FFB8B8B9\");\n    private static final int ANIMATION_DURATION \u003d 350;\n    private static final int ANIMATION_START_DELAY \u003d 150;\n    private static final android.view.animation.Interpolator ACCELERATE_INTERPOLATOR \u003d new AccelerateInterpolator();\n    private Paint mPaint;\n    private Paint mPaintShadow;\n    private Paint mPaintCircle;\n    private int mSize;\n    private float mScale;\n    private DiceRotation mDiceRotation;\n    private DiceState[] mDiceStates;\n    private int mDiceState;\n    private enum DiceSide {\n        ONE,\n        TWO,\n        THREE,\n        FOUR,\n        FIVE,\n        SIX\n    }\n    private enum DiceRotation {\n        LEFT,\n        DOWN;\n\n        DiceRotation invert() {\n            return this \u003d\u003d LEFT ? DOWN : LEFT;\n        }\n    }\n    private class DiceState {\n        private DiceSide side1;\n        private DiceSide side2;\n        DiceState(DiceSide side1, DiceSide side2) {\n            this.side1 \u003d side1;\n            this.side2 \u003d side2;\n        }\n    }\n    public GoogleMusicDicesDrawable() {\n        init();\n    }\n    private void init() {\n        mPaint \u003d new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(DICE_SIDE_COLOR);\n        mPaintShadow \u003d new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaintShadow.setColor(DICE_SIDE_SHADOW_COLOR);\n        mPaintCircle \u003d new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaintCircle.setColor(Color.WHITE);\n        mDiceStates \u003d new DiceState[] {\n                new DiceState(DiceSide.ONE, DiceSide.THREE),\n                new DiceState(DiceSide.TWO, DiceSide.THREE),\n                new DiceState(DiceSide.TWO, DiceSide.SIX),\n                new DiceState(DiceSide.FOUR, DiceSide.SIX),\n                new DiceState(DiceSide.FOUR, DiceSide.FIVE),\n                new DiceState(DiceSide.ONE, DiceSide.FIVE)\n        };\n        mDiceRotation \u003d DiceRotation.LEFT;\n        initObjectAnimator();\n    }\n    private void initObjectAnimator() {\n        final ObjectAnimator objectAnimator \u003d ObjectAnimator.ofFloat(this, \"scale\", 0, 1);\n        objectAnimator.setInterpolator(ACCELERATE_INTERPOLATOR);\n        objectAnimator.setDuration(ANIMATION_DURATION);\n        objectAnimator.setStartDelay(ANIMATION_START_DELAY);\n        objectAnimator.addListener(new AnimatorListenerAdapter() {\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                mScale \u003d 0;\n                mDiceState++;\n                if (mDiceState \u003d\u003d mDiceStates.length) {\n                    mDiceState \u003d 0;\n                }\n                mDiceRotation \u003d mDiceRotation.invert();\n                objectAnimator.start();\n            }\n        });\n        objectAnimator.start();\n    }\n    @Override\n    public void draw(Canvas canvas) {\n        if (mDiceRotation !\u003d null) {\n            switch (mDiceRotation) {\n                case DOWN:\n                    drawScaleY(canvas);\n                    break;\n                case LEFT:\n                    drawScaleX(canvas);\n                    break;\n            }\n        }\n    }\n    @Override\n    public void setAlpha(int alpha) {\n        mPaint.setAlpha(alpha);\n        mPaintShadow.setAlpha(alpha);\n        mPaintCircle.setAlpha(alpha);\n    }\n    @Override\n    public void setColorFilter(ColorFilter cf) {\n        mPaint.setColorFilter(cf);\n        mPaintShadow.setColorFilter(cf);\n        mPaintCircle.setColorFilter(cf);\n    }\n    @Override\n    public int getOpacity() {\n        return PixelFormat.TRANSLUCENT;\n    }\n    @Override\n    protected void onBoundsChange(Rect bounds) {\n        super.onBoundsChange(bounds);\n        mSize \u003d bounds.width();\n    }\n    @Override\n    public void invalidateDrawable(android.graphics.drawable.Drawable who) {\n        final Callback callback \u003d getCallback();\n        if (callback !\u003d null) {\n            callback.invalidateDrawable(this);\n        }\n    }\n    @Override\n    public void scheduleDrawable(android.graphics.drawable.Drawable who, Runnable what, long when) {\n        final Callback callback \u003d getCallback();\n        if (callback !\u003d null) {\n            callback.scheduleDrawable(this, what, when);\n        }\n    }\n    @Override\n    public void unscheduleDrawable(android.graphics.drawable.Drawable who, Runnable what) {\n        final Callback callback \u003d getCallback();\n        if (callback !\u003d null) {\n            callback.unscheduleDrawable(this, what);\n        }\n    }\n    private void drawScaleX(Canvas canvas) {\n        canvas.save();\n        Matrix matrix \u003d new Matrix();\n        matrix.preScale(1 - mScale, 1, 0, mSize / 2);\n        canvas.concat(matrix);\n        drawDiceSide(canvas, mDiceStates[mDiceState].side1, mScale \u003e 0.1f);\n        canvas.restore();\n        canvas.save();\n        matrix \u003d new Matrix();\n        matrix.preScale(mScale, 1, mSize, mSize / 2);\n        canvas.concat(matrix);\n        drawDiceSide(canvas, mDiceStates[mDiceState].side2, false);\n        canvas.restore();\n    }\n    private void drawScaleY(Canvas canvas) {\n        canvas.save();\n        Matrix matrix \u003d new Matrix();\n        matrix.preScale(1, mScale, mSize / 2, 0);\n        canvas.concat(matrix);\n        drawDiceSide(canvas, mDiceStates[mDiceState].side1, false);\n        canvas.restore();\n        canvas.save();\n        matrix \u003d new Matrix();\n        matrix.preScale(1, 1 - mScale, mSize / 2, mSize);\n        canvas.concat(matrix);\n        drawDiceSide(canvas, mDiceStates[mDiceState].side2, mScale \u003e 0.1f);\n        canvas.restore();\n    }\n    private void drawDiceSide(Canvas canvas, DiceSide side, boolean shadow) {\n        int circleRadius \u003d mSize / 10;\n        canvas.drawRect(0, 0, mSize, mSize, shadow ? mPaintShadow : mPaint);\n        switch (side) {\n            case ONE:\n                canvas.drawCircle(mSize / 2, mSize / 2, circleRadius, mPaintCircle);\n                break;\n            case TWO:\n                canvas.drawCircle(mSize / 4, mSize - mSize / 4, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize - mSize / 4, mSize / 4, circleRadius, mPaintCircle);\n                break;\n            case THREE:\n                canvas.drawCircle(mSize / 2, mSize / 2, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize / 4, mSize / 4, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize - mSize / 4, mSize - mSize / 4, mSize / 10, mPaintCircle);\n                break;\n            case FOUR:\n                canvas.drawCircle(mSize / 4, mSize / 4, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize / 4, mSize - mSize / 4, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize - mSize / 4, mSize - mSize / 4, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize - mSize / 4, mSize / 4, circleRadius, mPaintCircle);\n                break;\n            case FIVE:\n                canvas.drawCircle(mSize / 2, mSize / 2, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize / 4, mSize / 4, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize / 4, mSize - mSize / 4, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize - mSize / 4, mSize - mSize / 4, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize - mSize / 4, mSize / 4, circleRadius, mPaintCircle);\n                break;\n            case SIX:\n                canvas.drawCircle(mSize / 4, mSize / 4, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize / 4, mSize / 2, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize / 4, mSize - mSize / 4, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize - mSize / 4, mSize / 4, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize - mSize / 4, mSize / 2, circleRadius, mPaintCircle);\n                canvas.drawCircle(mSize - mSize / 4, mSize - mSize / 4, circleRadius, mPaintCircle);\n                break;\n        }\n    }\n    float getScale() {\n        return mScale;\n    }\n    void setScale(float scale) {\n        this.mScale \u003d scale;\n    }\n    public static class Builder {\n        public android.graphics.drawable.Drawable build() {\n            return new GoogleMusicDicesDrawable();\n        }\n    }\n}\n\n\npublic static class FoldingCirclesDrawable extends android.graphics.drawable.Drawable implements android.graphics.drawable.Drawable.Callback {\n    private static final float MAX_LEVEL \u003d 10000;\n    private static final float CIRCLE_COUNT \u003d ProgressStates.values().length;\n    private static final float MAX_LEVEL_PER_CIRCLE \u003d MAX_LEVEL / CIRCLE_COUNT;\n    private static final int ALPHA_OPAQUE \u003d 255;\n    private static final int ALPHA_ABOVE_DEFAULT \u003d 235;\n    private Paint mFstHalfPaint;\n    private Paint mScndHalfPaint;\n    private Paint mAbovePaint;\n    private RectF mOval \u003d new RectF();\n    private int mDiameter;\n    private Path mPath;\n    private int mHalf;\n    private ProgressStates mCurrentState;\n    private int mControlPointMinimum;\n    private int mControlPointMaximum;\n    private int mAxisValue;\n    private int mAlpha \u003d ALPHA_OPAQUE;\n    private ColorFilter mColorFilter;\n    private static int mColor1;\n    private static int mColor2;\n    private static int mColor3;\n    private static int mColor4;\n    private int fstColor, scndColor;\n    private boolean goesBackward;\n    private enum ProgressStates {\n        FOLDING_DOWN,\n        FOLDING_LEFT,\n        FOLDING_UP,\n        FOLDING_RIGHT\n    }\n    public FoldingCirclesDrawable(int[] colors) {\n        initCirclesProgress(colors);\n    }\n    private void initCirclesProgress(int[] colors) {\n        initColors(colors);\n        mPath \u003d new Path();\n        Paint basePaint \u003d new Paint();\n        basePaint.setAntiAlias(true);\n        mFstHalfPaint \u003d new Paint(basePaint);\n        mScndHalfPaint \u003d new Paint(basePaint);\n        mAbovePaint \u003d new Paint(basePaint);\n        setAlpha(mAlpha);\n        setColorFilter(mColorFilter);\n    }\n    private void initColors(int[] colors) {\n        mColor1\u003dcolors[0];\n        mColor2\u003dcolors[1];\n        mColor3\u003dcolors[2];\n        mColor4\u003dcolors[3];\n    }\n    @Override\n    protected void onBoundsChange(Rect bounds) {\n        super.onBoundsChange(bounds);\n        measureCircleProgress(bounds.width(), bounds.height());\n    }\n    @Override\n    protected boolean onLevelChange(int level) {\n        int animationLevel \u003d level \u003d\u003d MAX_LEVEL ? 0 : level;\n        int stateForLevel \u003d (int) (animationLevel / MAX_LEVEL_PER_CIRCLE);\n        mCurrentState \u003d ProgressStates.values()[stateForLevel];\n        resetColor(mCurrentState);\n        int levelForCircle \u003d (int) (animationLevel % MAX_LEVEL_PER_CIRCLE);\n        boolean halfPassed;\n        if (!goesBackward) {\n            halfPassed \u003d levelForCircle !\u003d (int) (animationLevel % (MAX_LEVEL_PER_CIRCLE / 2));\n        } else {\n            halfPassed \u003d levelForCircle \u003d\u003d (int) (animationLevel % (MAX_LEVEL_PER_CIRCLE / 2));\n            levelForCircle \u003d (int) (MAX_LEVEL_PER_CIRCLE - levelForCircle);\n        }\n        mFstHalfPaint.setColor(fstColor);\n        mScndHalfPaint.setColor(scndColor);\n        if (!halfPassed) {\n            mAbovePaint.setColor(mScndHalfPaint.getColor());\n        } else {\n            mAbovePaint.setColor(mFstHalfPaint.getColor());\n        }\n        setAlpha(mAlpha);\n        mAxisValue \u003d (int) (mControlPointMinimum + (mControlPointMaximum - mControlPointMinimum) * (levelForCircle / MAX_LEVEL_PER_CIRCLE));\n        return true;\n    }\n    private void resetColor(ProgressStates currentState) {\n        switch (currentState){\n            case FOLDING_DOWN:\n                fstColor\u003d mColor1;\n                scndColor\u003dmColor2;\n                goesBackward\u003dfalse;\n            break;\n            case FOLDING_LEFT:\n                fstColor\u003d mColor1;\n                scndColor\u003dmColor3;\n                goesBackward\u003dtrue;\n                break;\n            case FOLDING_UP:\n                fstColor\u003d mColor3;\n                scndColor\u003dmColor4;\n                goesBackward\u003dtrue;\n                break;\n            case FOLDING_RIGHT:\n                fstColor\u003dmColor2;\n                scndColor\u003dmColor4;\n                goesBackward\u003dfalse;\n                break;\n        }\n    }\n    @Override\n    public void draw(Canvas canvas) {\n        if (mCurrentState !\u003d null) {\n            makeCirclesProgress(canvas);\n        }\n    }\n    private void measureCircleProgress(int width, int height) {\n        mDiameter \u003d Math.min(width, height);\n        mHalf \u003d mDiameter / 2;\n        mOval.set(0, 0, mDiameter, mDiameter);\n        mControlPointMinimum \u003d -mDiameter / 6;\n        mControlPointMaximum \u003d mDiameter + mDiameter / 6;\n    }\n    private void makeCirclesProgress(Canvas canvas) {\n        switch (mCurrentState) {\n            case FOLDING_DOWN:\n            case FOLDING_UP:\n                drawYMotion(canvas);\n                break;\n            case FOLDING_RIGHT:\n            case FOLDING_LEFT:\n                drawXMotion(canvas);\n                break;\n        }\n        canvas.drawPath(mPath, mAbovePaint);\n    }\n    private void drawXMotion(Canvas canvas) {\n        canvas.drawArc(mOval, 90, 180, true, mFstHalfPaint);\n        canvas.drawArc(mOval, -270, -180, true, mScndHalfPaint);\n        mPath.reset();\n        mPath.moveTo(mHalf, 0);\n        mPath.cubicTo(mAxisValue, 0, mAxisValue, mDiameter, mHalf, mDiameter);\n        mPath.moveTo(mHalf+1, 0);\n        mPath.cubicTo(mAxisValue, 0, mAxisValue, mDiameter, mHalf+1, mDiameter);\n    }\n    private void drawYMotion(Canvas canvas) {\n        canvas.drawArc(mOval, 0, -180, true, mFstHalfPaint);\n        canvas.drawArc(mOval, -180, -180, true, mScndHalfPaint);\n        mPath.reset();\n        mPath.moveTo(0, mHalf);\n        mPath.cubicTo(0, mAxisValue, mDiameter, mAxisValue, mDiameter, mHalf);\n        mPath.moveTo(0, mHalf+1);\n        mPath.cubicTo(0, mAxisValue, mDiameter, mAxisValue, mDiameter, mHalf+1);\n    }\n    @Override\n    public void setAlpha(int alpha) {\n        this.mAlpha \u003d alpha;\n        mFstHalfPaint.setAlpha(alpha);\n        mScndHalfPaint.setAlpha(alpha);\n        int targetAboveAlpha \u003d (ALPHA_ABOVE_DEFAULT * alpha) / ALPHA_OPAQUE;\n        mAbovePaint.setAlpha(targetAboveAlpha);\n    }\n    @Override\n    public void setColorFilter(ColorFilter cf) {\n        this.mColorFilter \u003d cf;\n        mFstHalfPaint.setColorFilter(cf);\n        mScndHalfPaint.setColorFilter(cf);\n        mAbovePaint.setColorFilter(cf);\n    }\n    @Override\n    public int getOpacity() {\n        return PixelFormat.TRANSLUCENT;\n    }\n    @Override\n    public void invalidateDrawable(android.graphics.drawable.Drawable who) {\n        final Callback callback \u003d getCallback();\n        if (callback !\u003d null) {\n            callback.invalidateDrawable(this);\n        }\n    }\n    @Override\n    public void scheduleDrawable(android.graphics.drawable.Drawable who, Runnable what, long when) {\n        final Callback callback \u003d getCallback();\n        if (callback !\u003d null) {\n            callback.scheduleDrawable(this, what, when);\n        }\n    }\n    @Override\n    public void unscheduleDrawable(android.graphics.drawable.Drawable who, Runnable what) {\n        final Callback callback \u003d getCallback();\n        if (callback !\u003d null) {\n            callback.unscheduleDrawable(this, what);\n        }\n    }\n    public static class Builder {\n        private int[] mColors;\n        public Builder(Context context){\n            initDefaults(context);\n        }\n        \n        private void initDefaults(Context context) {\n            //Default values\n            mColors \u003d new int[]{0xFFC93437, 0xFF375BF1, 0xFFF7D23E, 0xFF34A350}; //Red, blue, yellow, green\n        }\n        \n        public Builder colors(int[] colors) {\n            if (colors \u003d\u003d null || colors.length \u003d\u003d 0) {\n                throw new IllegalArgumentException(\"Your color array must contains at least 4 values\");\n            }\n            mColors \u003d colors;\n            return this;\n        }\n        public android.graphics.drawable.Drawable build() {\n            return new FoldingCirclesDrawable(mColors);\n        }\n    }\n}\n\n\npublic static class ChromeFloatingCirclesDrawable extends android.graphics.drawable.Drawable implements android.graphics.drawable.Drawable.Callback {\n    private static final int MAX_LEVEL \u003d 10000;\n    private static final int CENT_LEVEL \u003d MAX_LEVEL / 2;\n    private static final int MID_LEVEL \u003d CENT_LEVEL / 2;\n    private static final int ALPHA_OPAQUE \u003d 255;\n    private static final int ACCELERATION_LEVEL \u003d 2;\n    private int mAlpha \u003d ALPHA_OPAQUE;\n    private ColorFilter mColorFilter;\n    private Point[] mArrowPoints;\n    private Paint mPaint1;\n    private Paint mPaint2;\n    private Paint mPaint3;\n    private Paint mPaint4;\n    private double unit;\n    private int width, x_beg, y_beg, x_end, y_end, offset;\n    private int acceleration \u003d ACCELERATION_LEVEL;\n    private double distance \u003d 0.5 * ACCELERATION_LEVEL * MID_LEVEL * MID_LEVEL;\n    private double max_speed; // set in setAcceleration(...);\n    private double offsetPercentage;\n    private int colorSign;\n    private ProgressStates currentProgressStates \u003d ProgressStates.GREEN_TOP;\n    private enum ProgressStates {\n        GREEN_TOP,\n        YELLOW_TOP,\n        RED_TOP,\n        BLUE_TOP\n    }\n    public ChromeFloatingCirclesDrawable(int[] colors) {\n        initCirclesProgress(colors);\n    }\n    private void initCirclesProgress(int[] colors) {\n        initColors(colors);\n        setAlpha(mAlpha);\n        setColorFilter(mColorFilter);\n        setAcceleration(ACCELERATION_LEVEL);\n        offsetPercentage \u003d 0;\n        colorSign \u003d 1; // |\u003d 1, |\u003d 2, |\u003d 4, |\u003d 8 --\u003e 0xF\n    }\n\n    private void initColors(int[] colors) {\n        mPaint1 \u003d new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint1.setColor(colors[0]);\n        mPaint1.setAntiAlias(true);\n        mPaint2 \u003d new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint2.setColor(colors[1]);\n        mPaint2.setAntiAlias(true);\n        mPaint3 \u003d new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint3.setColor(colors[2]);\n        mPaint3.setAntiAlias(true);\n        mPaint4 \u003d new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint4.setColor(colors[3]);\n        mPaint4.setAntiAlias(true);\n    }\n    @Override\n    protected void onBoundsChange(Rect bounds) {\n        super.onBoundsChange(bounds);\n        measureCircleProgress(bounds.width(), bounds.height());\n    }\n    @Override\n    protected boolean onLevelChange(int level) {\n        level %\u003d MAX_LEVEL / acceleration;\n        final int temp_level \u003d level % (MID_LEVEL / acceleration);\n        final int ef_width \u003d (int)(unit * 3.0); // effective width\n        if(level \u003c CENT_LEVEL / acceleration) { // go\n            if(level \u003c MID_LEVEL / acceleration) {\n                if(colorSign \u003d\u003d 0xF) {\n                    changeTopColor();\n                    colorSign \u003d 1;\n                }\n                offsetPercentage \u003d 0.5 * acceleration * temp_level * temp_level / distance;\n                offset \u003d (int)(offsetPercentage * ef_width / 2); // x and y direction offset\n            }\n            else {\n                colorSign |\u003d 2;\n                // from mid to end\n                offsetPercentage \u003d (max_speed * temp_level\n                        - 0.5 * acceleration * temp_level * temp_level) / distance\n                        + 1.0;\n                offset \u003d (int)(offsetPercentage * ef_width / 2); // x and y direction offset\n            }\n        }\n        else { // back\n            if(level \u003c (CENT_LEVEL + MID_LEVEL) / acceleration) {\n                // set colorSign\n                if(colorSign \u003d\u003d 0x3) {\n                    changeTopColor();\n                    colorSign |\u003d 4;\n                }\n                // from end to mid\n                offsetPercentage \u003d 0.5 * acceleration * temp_level * temp_level  / distance;\n                offset \u003d (int)(ef_width - offsetPercentage * ef_width / 2); // x and y direction offset\n            }\n            else {\n                // set colorSign\n                colorSign |\u003d 8;\n                // from mid to beg\n                offsetPercentage \u003d (max_speed * temp_level\n                        - 0.5 * acceleration * temp_level * temp_level) / distance\n                        + 1.0;\n                offsetPercentage \u003d offsetPercentage \u003d\u003d 1.0 ? 2.0 : offsetPercentage;\n                offset \u003d (int)(ef_width - offsetPercentage * ef_width / 2); // x and y direction offset\n            }\n        }\n\n        mArrowPoints[0].set((int)unit+x_beg+offset, (int)unit+y_beg+offset); // mPaint1, left up\n        mArrowPoints[1].set((int)(unit*4.0)+x_beg-offset, (int)(unit*4.0)+y_beg-offset); // mPaint2, right down\n        mArrowPoints[2].set((int)unit+x_beg+offset, (int)(unit*4.0)+y_beg-offset); // mPaint3, left down\n        mArrowPoints[3].set((int)(unit*4.0)+x_beg-offset, (int)unit+y_beg+offset); // mPaint4, right up\n\n        return true;\n    }\n\n    private void changeTopColor() {\n        switch(currentProgressStates){\n            case GREEN_TOP:\n                currentProgressStates \u003d ProgressStates.YELLOW_TOP;\n                break;\n            case YELLOW_TOP:\n                currentProgressStates \u003d ProgressStates.RED_TOP;\n                break;\n            case RED_TOP:\n                currentProgressStates \u003d ProgressStates.BLUE_TOP;\n                break;\n            case BLUE_TOP:\n                currentProgressStates \u003d ProgressStates.GREEN_TOP;\n                break;\n        }\n    }\n\n    @Override\n    public void draw(Canvas canvas) {\n        // draw circles\n        if(currentProgressStates !\u003d ProgressStates.RED_TOP)\n            canvas.drawCircle(mArrowPoints[0].x, mArrowPoints[0].y, (float)unit, mPaint1);\n        if(currentProgressStates !\u003d ProgressStates.BLUE_TOP)\n            canvas.drawCircle(mArrowPoints[1].x, mArrowPoints[1].y, (float)unit, mPaint2);\n        if(currentProgressStates !\u003d ProgressStates.YELLOW_TOP)\n            canvas.drawCircle(mArrowPoints[2].x, mArrowPoints[2].y, (float)unit, mPaint3);\n        if(currentProgressStates !\u003d ProgressStates.GREEN_TOP)\n            canvas.drawCircle(mArrowPoints[3].x, mArrowPoints[3].y, (float)unit, mPaint4);\n\n        // draw the top one\n        switch(currentProgressStates){\n            case GREEN_TOP:\n                canvas.drawCircle(mArrowPoints[3].x, mArrowPoints[3].y, (float)unit, mPaint4);\n                break;\n            case YELLOW_TOP:\n                canvas.drawCircle(mArrowPoints[2].x, mArrowPoints[2].y, (float)unit, mPaint3);\n                break;\n            case RED_TOP:\n                canvas.drawCircle(mArrowPoints[0].x, mArrowPoints[0].y, (float)unit, mPaint1);\n                break;\n            case BLUE_TOP:\n                canvas.drawCircle(mArrowPoints[1].x, mArrowPoints[1].y, (float)unit, mPaint2);\n                break;\n        }\n    }\n\n    private void measureCircleProgress(int width, int height) {\n        // get min edge as width\n        if(width \u003e height) {\n            // use height\n            this.width \u003d height - 1; // minus 1 to avoid \"3/2\u003d1\"\n            x_beg \u003d (width - height) / 2 + 1;\n            y_beg \u003d 1;\n            x_end \u003d x_beg + this.width;\n            y_end \u003d this.width;\n        }\n        else {\n            //use width\n            this.width \u003d width - 1;\n            x_beg \u003d 1;\n            y_beg \u003d (height - width) / 2 + 1;\n            x_end \u003d this.width;\n            y_end \u003d y_beg + this.width;\n        }\n        unit \u003d (double)this.width / 5.0;\n\n        // init the original position, and then set position by offsets\n        mArrowPoints \u003d new Point[4];\n        mArrowPoints[0] \u003d new Point((int)unit+x_beg, (int)unit+y_beg); // mPaint1, left up\n        mArrowPoints[1] \u003d new Point((int)(unit*4.0)+x_beg, (int)(unit*4.0)+y_beg); // mPaint2, right down\n        mArrowPoints[2] \u003d new Point((int)unit+x_beg, (int)(unit*4.0)+y_beg); // mPaint3, left down\n        mArrowPoints[3] \u003d new Point((int)(unit*4.0)+x_beg, (int)unit+y_beg); // mPaint4, right up\n    }\n\n    public void setAcceleration(int acceleration) {\n        this.acceleration \u003d acceleration;\n        distance \u003d 0.5 * acceleration * (MID_LEVEL / acceleration) * (MID_LEVEL / acceleration);\n        max_speed \u003d acceleration * (MID_LEVEL / acceleration);\n    }\n\n    @Override\n    public void setAlpha(int alpha) {\n        mPaint1.setAlpha(alpha);\n        mPaint2.setAlpha(alpha);\n        mPaint3.setAlpha(alpha);\n        mPaint4.setAlpha(alpha);\n    }\n\n    @Override\n    public void setColorFilter(ColorFilter cf) {\n        mColorFilter \u003d cf;\n        mPaint1.setColorFilter(cf);\n        mPaint2.setColorFilter(cf);\n        mPaint3.setColorFilter(cf);\n        mPaint4.setColorFilter(cf);\n    }\n\n    @Override\n    public int getOpacity() {\n        return PixelFormat.TRANSLUCENT;\n    }\n\n    @Override\n    public void invalidateDrawable(android.graphics.drawable.Drawable who) {\n        final Callback callback \u003d getCallback();\n        if (callback !\u003d null) {\n            callback.invalidateDrawable(this);\n        }\n    }\n\n    @Override\n    public void scheduleDrawable(android.graphics.drawable.Drawable who, Runnable what, long when) {\n        final Callback callback \u003d getCallback();\n        if (callback !\u003d null) {\n            callback.scheduleDrawable(this, what, when);\n        }\n    }\n\n    @Override\n    public void unscheduleDrawable(android.graphics.drawable.Drawable who, Runnable what) {\n        final Callback callback \u003d getCallback();\n        if (callback !\u003d null) {\n            callback.unscheduleDrawable(this, what);\n        }\n    }\n\n    public static class Builder {\n        private int[] mColors;\n\n        public Builder(Context context){\n            initDefaults(context);\n            return;\n        }\n\t\t\n        private void initDefaults(Context context) {\n            //Default values\n            mColors \u003d new int[]{0xFFC93437, 0xFF375BF1, 0xFFF7D23E, 0xFF34A350}; //Red, blue, yellow, green\n            return;\n        }\n\t\t\n        public Builder colors(int[] colors) {\n            if (colors \u003d\u003d null || colors.length \u003d\u003d 0) {\n                throw new IllegalArgumentException(\"Your color array must contains at least 4 values\");\n            }\n\n            mColors \u003d colors;\n            return this;\n        }\n\n        public android.graphics.drawable.Drawable build() {\n            return new ChromeFloatingCirclesDrawable(mColors);\n        }\n    }\n}\n{"},{"name":"GProg : FoldingCircles","palette":"56","spec":"%m.progressbar setProgressType : FoldingCircles","type":" ","code":"%1$s.setIndeterminateDrawable(new FoldingCirclesDrawable.Builder(this).colors(new int[]{0xFFC93437, 0xFF375BF1, 0xFFF7D23E, 0xFF34A350}).build());"},{"name":"GProg : NexusRotationCross","palette":"56","spec":"%m.progressbar setProgressType : NexusRotationCross","type":" ","code":"%1$s.setIndeterminateDrawable(new NexusRotationCrossDrawable.Builder(this).colors(new int[]{0xFFC93437, 0xFF375BF1, 0xFFF7D23E, 0xFF34A350}).build());"},{"name":"GProg : ChromeFloatingCircles","palette":"56","spec":"%m.progressbar setProgressType : ChromeFloatingCircles","type":" ","code":"%1$s.setIndeterminateDrawable(new ChromeFloatingCirclesDrawable.Builder(this).colors(new int[]{0xFFC93437, 0xFF375BF1, 0xFFF7D23E, 0xFF34A350}).build());"}]